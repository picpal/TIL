# 알고리즘,자료구조

[visualising data structures and algorithms through animation - VisuAlgo](https://visualgo.net/en)

# 그래프탐색 이란

- 하나의 정점으로부터 시작하여 차례대로 모든 정점들을 한 번씩 방문하는 것
- Ex) 특정 도시에서 다른 도시로 갈 수 있는지 없는지, 전자 회로에서 특정 단자와 단자가 서로 연결되어 있는지

# 너비 우선 탐색 (BFS , Breadth-First Search)

### 너비우선탐색이란

- 루트 노드(혹은 다른 임의의 노드)에서 시작해서 인접한 노드를 먼저 탐색하는 방법
- 시작 정점으로부터 가까운 정점을 먼저 방문하고 멀리 떨어져 있는 정점을 나중에 방문하는 순회 방법이다.
- 즉, 깊게(deep) 탐색하기 전에 넓게(wide) 탐색하는 것이다.
- 사용하는 경우: 두 노드 사이의 최단 경로 혹은 임의의 경로를 찾고 싶을 때 이 방법을 선택한다.
    - Ex) 지구상에 존재하는 모든 친구 관계를 그래프로 표현한 후 Ash와 Vanessa 사이에 존재하는 경로를 찾는 경우
    - 깊이 우선 탐색의 경우 - 모든 친구 관계를 다 살펴봐야 할지도 모른다.
    - 너비 우선 탐색의 경우 - Ash와 가까운 관계부터 탐색
    - 너비 우선 탐색(BFS)이 깊이 우선 탐색(DFS)보다 좀 더 복잡하다.
    

### 너비 우선 탐색(BFS)의 특징

- 직관적이지 않은 면이 있다.
    - BFS는 시작 노드에서 시작해서 거리에 따라 단계별로 탐색한다고 볼 수 있다.
- BFS는 재귀적으로 동작하지 않는다.
이 알고리즘을 구현할 때 가장 큰 차이점은, 그래프 탐색의 경우 어떤 노드를 방문했었는지 여부를 반드시 검사 해야 한다는 것이다.
- 이를 검사하지 않을 경우 무한루프에 빠질 위험이 있다.
- BFS는 방문한 노드들을 차례로 저장한 후 꺼낼 수 있는 자료 구조인 큐(Queue)를 사용한다.
    - 즉, 선입선출(FIFO) 원칙으로 탐색
    - 일반적으로 큐를 이용해서 반복적 형태로 구현하는 것이 가장 잘 동작한다.
- ‘Prim’, ‘Dijkstra’ 알고리즘과 유사하다.

### 너비 우선 탐색(BFS)의 과정

- 깊이가 1인 모든 노드를 방문하고 나서 그 다음에는 깊이가 2인 모든 노드를, 그 다음에는 깊이가 3인 모든 노드를 방문하는 식으로 계속 방문하다가 더 이상 방문할 곳이 없으면 탐색을 마친다.

![Untitled](%E1%84%8B%E1%85%A1%E1%86%AF%E1%84%80%E1%85%A9%E1%84%85%E1%85%B5%E1%84%8C%E1%85%B3%E1%86%B7,%E1%84%8C%E1%85%A1%E1%84%85%E1%85%AD%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A9%2049af8291da234d6dbe835dcc2dda5518/Untitled.png)

1. a 노드(시작 노드)를 방문한다. (방문한 노드 체크)
    - 큐에 방문된 노드를 삽입(enqueue)한다.
    - 초기 상태의 큐에는 시작 노드만이 저장
        - 즉, a 노드의 이웃 노드를 모두 방문한 다음에 이웃의 이웃들을 방문한다.
2. 큐에서 꺼낸 노드과 인접한 노드들을 모두 차례로 방문한다.
    - 큐에서 꺼낸 노드를 방문한다.
    - 큐에서 커낸 노드과 인접한 노드들을 모두 방문한다.
        - 인접한 노드가 없다면 큐의 앞에서 노드를 꺼낸다(dequeue).
    - 큐에 방문된 노드를 삽입(enqueue)한다.
3. 큐가 소진될 때까지 계속한다.

### 너비 우선 탐색(BFS)의 구현

- 구현 방법
    - 자료 구조 큐(Queue)를 이용
- BFS 의사코드(pseudocode)

```java
void search(Node root) {
  Queue queue = new Queue();
  root.marked = true; // (방문한 노드 체크)
  queue.enqueue(root); // 1-1. 큐의 끝에 추가

  // 3. 큐가 소진될 때까지 계속한다.
  while (!queue.isEmpty()) {
    Node r = queue.dequeue(); // 큐의 앞에서 노드 추출
    visit(r); // 2-1. 큐에서 추출한 노드 방문
    // 2-2. 큐에서 꺼낸 노드와 인접한 노드들을 모두 차례로 방문한다.
    foreach (Node n in r.adjacent) {
      if (n.marked == false) {
        n.marked = true; // (방문한 노드 체크)
        queue.enqueue(n); // 2-3. 큐의 끝에 추가
      }
    }
  }
}
```

```java
import java.io.*;
import java.util.*;

/* 인접 리스트를 이용한 방향성 있는 그래프 클래스 */
class Graph {
  private int V; // 노드의 개수
  private LinkedList<Integer> adj[]; // 인접 리스트

  /** 생성자 */
  Graph(int v) {
    V = v;
    adj = new LinkedList[v];
    for (int i=0; i<v; ++i) // 인접 리스트 초기화
      adj[i] = new LinkedList();
  }

  /** 노드를 연결 v->w */
  void addEdge(int v, int w) { adj[v].add(w); }

  /** s를 시작 노드으로 한 BFS로 탐색하면서 탐색한 노드들을 출력 */
  void BFS(int s) {
    // 노드의 방문 여부 판단 (초깃값: false)
    boolean visited[] = new boolean[V];
    // BFS 구현을 위한 큐(Queue) 생성
    LinkedList<Integer> queue = new LinkedList<Integer>();

    // 현재 노드를 방문한 것으로 표시하고 큐에 삽입(enqueue)
    visited[s] = true;
    queue.add(s);

    // 큐(Queue)가 빌 때까지 반복
    while (queue.size() != 0) {
      // 방문한 노드를 큐에서 추출(dequeue)하고 값을 출력
      s = queue.poll();
      System.out.print(s + " ");

      // 방문한 노드와 인접한 모든 노드를 가져온다.
      Iterator<Integer> i = adj[s].listIterator();
      while (i.hasNext()) {
        int n = i.next();
        // 방문하지 않은 노드면 방문한 것으로 표시하고 큐에 삽입(enqueue)
        if (!visited[n]) {
          visited[n] = true;
          queue.add(n);
        }
      }
    }
  }
}
```

```java
/** 사용 방법 */
public static void main(String args[]) {
  Graph g = new Graph(4);

  g.addEdge(0, 1);
  g.addEdge(0, 2);
  g.addEdge(1, 2);
  g.addEdge(2, 0);
  g.addEdge(2, 3);
  g.addEdge(3, 3);

  g.BFS(2); /* 주어진 노드를 시작 노드로 BFS 탐색 */
}
```

### 너비 우선 탐색(BFS)의 시간 복잡도

- 인접 리스트로 표현된 그래프: O(N+E)
- 인접 행렬로 표현된 그래프: O(N^2)
- 깊이 우선 탐색(DFS)과 마찬가지로 그래프 내에 적은 숫자의 간선만을 가지는 희소 그래프(Sparse Graph) 의 경우 인접 행렬보다 인접 리스트를 사용하는 것이 유리하다.

관련된 Post
트리 : [https://gmlwjd9405.github.io/2018/08/12/data-structure-tree.html](https://gmlwjd9405.github.io/2018/08/12/data-structure-tree.html)
그래프 : [https://gmlwjd9405.github.io/2018/08/13/data-structure-graph.html](https://gmlwjd9405.github.io/2018/08/13/data-structure-graph.html)

**BFS/DFS 예제 ( Javascript )**

![Untitled](%E1%84%8B%E1%85%A1%E1%86%AF%E1%84%80%E1%85%A9%E1%84%85%E1%85%B5%E1%84%8C%E1%85%B3%E1%86%B7,%E1%84%8C%E1%85%A1%E1%84%85%E1%85%AD%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A9%2049af8291da234d6dbe835dcc2dda5518/Untitled%201.png)

```jsx
//BFS 방식: A - B - C - D - G - H - I - E - F - J

const graph = {
    A: ['B', 'C'],
    B: ['A', 'D'],
    C: ['A', 'G', 'H', 'I'],
    D: ['B', 'E', 'F'],
    E: ['D'],
    F: ['D'],
    G: ['C'],
    H: ['C'],
    I: ['C', 'J'],
    J: ['I']
  };

const BFS = (graph , startNode) => {
    const visited = []; // 탐색을 마친 노드들
    let needVisit = []; // 탐색해야할 노드들

    needVisit.push(startNode); // 노드 탐색 시작

    while(needVisit.length !== 0){
        const node = needVisit.shift(); // queue이기 때문에 선입선출 , shift()를 사용
        if(!visited.includes(node)){ // 해당 노드가 탐색된 적 없다면
            visited.push(node);
            needVisit = [...needVisit , ...graph[node]];
        }
    }
    return visited;
}

const result = BFS(graph,"A");

console.log(result);
```

```jsx
class Node{
    constructor(data){
        this.data = data; // 다른 노드와 차별점을 두는 데이터
        this.children = []; // 자식들과의 정보(주소)를 담을 배열
    }

    add(data){
        this.children.push(new Node(data)); // 자식노드를 생성하고 바로 배열에 저장한다. (주소를 저장하는 행위)
    }

    remove(data){
        this.children = this.children.filter(child => child.data === data ? false : true); // 해당하는 자식의 정보를 배열에서 빼주기 위한 filter
    }
}

class Tree{
    constructor(){
        this.root = null;
    }

    BFS(fn){
        if(this.root === null) return;

        const unvisitedQueue = [this.root];
        while(unvisitedQueue.length !== 0){
            const current = unvisitedQueue.shift(); 
            unvisitedQueue.push(...current.children); // 현재 부모 노드의 자식들을 모두 큐에 담는다
            fn(current); //현재 노드를 가지고 callback 함수 실행
        }

    }

    DFS(fn) {
        if(this.root === null) return;

        const unvisitedList = [this.root];
        while(unvisitedList.length !== 0) {
            const current = unvisitedList.shift();
            unvisitedList.unshift(...current.children); // list 앞에다 넣어준다. (우선순위: 내 자식들이 먼저야! )
            fn(current);
        }
    }

}

const treeObj = new Tree(); // 빈트리 생성
treeObj.root = new Node('a'); // 루트가 node 'a'의 주소를 가리키면 'a'의 자식들까지 접근가능하다. 
treeObj.root.add('b'); // a의 자식 'b','c'
treeObj.root.add('c');
treeObj.root.children[0].add('d'); // 'b'의 자식으로 'd'가 추가된다.

const lettersBFS = [];
const lettersDFS = [];
treeObj.BFS(node => lettersBFS.push(node.data));
treeObj.DFS(node => lettersDFS.push(node.data));

console.log(lettersBFS);
console.log(lettersDFS);
```

# 깊이 우선 탐색 (DFS: Depth-First Search)

### 깊이 우선 탐색이란

- 루트 노드(혹은 다른 임의의 노드)에서 시작해서 다음 분기(branch)로 넘어가기 전에 해당 분기를 완벽하게 탐색하는 방법
- 미로를 탐색할 때 한 방향으로 갈 수 있을 때까지 계속 가다가 더 이상 갈 수 없게 되면 다시 가장 가까운 갈림길로 돌아와서 이곳으로부터 다른 방향으로 다시 탐색을 진행하는 방법과 유사하다.
- 즉, 넓게(wide) 탐색하기 전에 깊게(deep) 탐색하는 것이다.
- 사용하는 경우: 모든 노드를 방문 하고자 하는 경우에 이 방법을 선택한다.
- 깊이 우선 탐색(DFS)이 너비 우선 탐색(BFS)보다 좀 더 간단하다.
- 단순 검색 속도 자체는 너비 우선 탐색(BFS)에 비해서 느리다.

### 깊이 우선 탐색(DFS)의 특징

- 자기 자신을 호출하는 순환 알고리즘의 형태 를 가지고 있다.
- 전위 순회(Pre-Order Traversals)를 포함한 다른 형태의 트리 순회는 모두 DFS의 한 종류이다.
- 이 알고리즘을 구현할 때 가장 큰 차이점은, 그래프 탐색의 경우 어떤 노드를 방문했었는지 여부를 **반드시 검사** 해야 한다는 것이다. 이를 검사하지 않을 경우 무한루프에 빠질 위험이 있다.

### 깊이 우선 탐색(DFS)의 과정

![Untitled](%E1%84%8B%E1%85%A1%E1%86%AF%E1%84%80%E1%85%A9%E1%84%85%E1%85%B5%E1%84%8C%E1%85%B3%E1%86%B7,%E1%84%8C%E1%85%A1%E1%84%85%E1%85%AD%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A9%2049af8291da234d6dbe835dcc2dda5518/Untitled%202.png)

1. a 노드(시작 노드)를 방문한다.
    - 방문한 노드는 방문했다고 표시한다.
2. a와 인접한 노드들을 차례로 순회한다.
    - a와 인접한 노드가 없다면 종료한다.
3. a와 이웃한 노드 b를 방문했다면, a와 인접한 또 다른 노드를 방문하기 전에 b의 이웃 노드들을 전부 방문해야 한다.
    - b를 시작 정점으로 DFS를 다시 시작하여 b의 이웃 노드들을 방문한다.
4. b의 분기를 전부 완벽하게 탐색했다면 다시 a에 인접한 정점들 중에서 아직 방문이 안 된 정점을 찾는다.
    - 즉, b의 분기를 전부 완벽하게 탐색한 뒤에야 a의 다른 이웃 노드를 방문할 수 있다는 뜻이다.
    - 아직 방문이 안 된 정점이 없으면 종료한다.
    - 있으면 다시 그 정점을 시작 정점으로 DFS를 시작한다
    

### 깊이 우선 탐색(DFS)의 구현 방법 2가지

1. 순환 호출 이용
2. 명시적인 스택 사용
    - 명시적인 스택을 사용하여 방문한 정점들을 스택에 저장하였다가 다시 꺼내어 작업한다.
    순환 호출을 이용한 DFS 의사코드(pseudocode)
    1. 순환 호출을 이용한 DFS 의사코드(pseudocode)
    
    ```java
    void search(Node root) {
      if (root == null) return;
      // 1. root 노드 방문
      visit(root);
      root.visited = true; // 1-1. 방문한 노드를 표시
      // 2. root 노드와 인접한 정점을 모두 방문
      for each (Node n in root.adjacent) {
        if (n.visited == false) { // 4. 방문하지 않은 정점을 찾는다.
          search(n); // 3. root 노드와 인접한 정점 정점을 시작 정점으로 DFS를 시작
        }
      }
    }
    ```
    
    ```java
    import java.io.*;
    import java.util.*;
    
    /* 인접 리스트를 이용한 방향성 있는 그래프 클래스 */
    class Graph {
      private int V;   // 노드의 개수
      private LinkedList<Integer> adj[]; // 인접 리스트
    
      /** 생성자 */
      Graph(int v) {
          V = v;
          adj = new LinkedList[v];
          for (int i=0; i<v; ++i) // 인접 리스트 초기화
              adj[i] = new LinkedList();
      }
    
      /** 노드를 연결 v->w */
      void addEdge(int v, int w) { adj[v].add(w); }
    
      /** DFS에 의해 사용되는 함수 */
      void DFSUtil(int v, boolean visited[]) {
          // 현재 노드를 방문한 것으로 표시하고 값을 출력
          visited[v] = true;
          System.out.print(v + " ");
    
          // 방문한 노드와 인접한 모든 노드를 가져온다.
          Iterator<Integer> i = adj[v].listIterator();
          while (i.hasNext()) {
              int n = i.next();
              // 방문하지 않은 노드면 해당 노드를 시작 노드로 다시 DFSUtil 호출
              if (!visited[n])
                  DFSUtil(n, visited); // 순환 호출
          }
      }
    
      /** 주어진 노드를 시작 노드로 DFS 탐색 */
      void DFS(int v) {
          // 노드의 방문 여부 판단 (초깃값: false)
          boolean visited[] = new boolean[V];
    
          // v를 시작 노드로 DFSUtil 순환 호출
          DFSUtil(v, visited);
      }
    
      /** DFS 탐색 */
      void DFS() {
          // 노드의 방문 여부 판단 (초깃값: false)
          boolean visited[] = new boolean[V];
    
          // 비연결형 그래프의 경우, 모든 정점을 하나씩 방문
          for (int i=0; i<V; ++i) {
              if (visited[i] == false)
                  DFSUtil(i, visited);
          }
      }
    }
    ```
    
    ```java
    /** 사용 방법 */
    public static void main(String args[]) {
        Graph g = new Graph(4);
    
        g.addEdge(0, 1);
        g.addEdge(0, 2);
        g.addEdge(1, 2);
        g.addEdge(2, 0);
        g.addEdge(2, 3);
        g.addEdge(3, 3);
    
        g.DFS(2); /* 주어진 노드를 시작 노드로 DFS 탐색 */
        g.DFS(); /* 비연결형 그래프의 경우 */
    }
    ```
    
    ### 깊이 우선 탐색(DFS)의 시간 복잡도
    
    - DFS는 그래프(정점의 수: N, 간선의 수: E)의 모든 간선을 조회한다.
        - 인접 리스트로 표현된 그래프: O(N+E)
        - 인접 행렬로 표현된 그래프: O(N^2)
    - 즉, 그래프 내에 적은 숫자의 간선만을 가지는 희소 그래프(Sparse Graph) 의 경우 인접 행렬보다 인접 리스트를 사용하는 것이 유리하다.
    
    ```jsx
    //DFS 방식: A - B - D - E - F - C - G - H - I - J
    
    const graph = {
        A: ["B", "C"],
        B: ["A", "D"],
        C: ["A", "G", "H", "I"],
        D: ["B", "E", "F"],
        E: ["D"],
        F: ["D"],
        G: ["C"],
        H: ["C"],
        I: ["C", "J"],
        J: ["I"]
    };
    
    const DFS = (graph , startNode) => {
        const visited = []; // 탐색을 마친 노드들
        let needVisit = []; // 탐색해야할 노드들
    
        needVisit.push(startNode); // 노드 탐색 시작
    
        while(needVisit.length !== 0){ //탐색할 노드가 남아있을때 까지
            const node = needVisit.shift(); // queue 이기 때문에 선입선출 , shift()를 사용
            if (!visited.includes(node)) { // 해당 노드가 탐색된 적 없다면
                visited.push(node); 
                needVisit = [...graph[node], ...needVisit];
            }
        }
    
        return visited;
    }
    
    console.log(DFS(graph, "A"));
    ```
    

# 선택정렬(Selection Sort)

선택 정렬은 일단 자리는 정해져있습니다. 첫번째 자리에 가장 작은 녀석을 집어넣으면 되죠. 그리고 난 후에 두번째 자리에 그 다음 가장 작은 녀석을 선택해 집어 넣습니다. 이 짓을 배열이 끝날때까지 합니다.

다음 배열 arr에는 9, 8, 1, 2, 3이 있습니다. 이것을 선택정렬로 정렬하도록 해봅시다.

[https://t1.daumcdn.net/cfile/tistory/99D2F5435BEFB65C1D](https://t1.daumcdn.net/cfile/tistory/99D2F5435BEFB65C1D)

우선 제일 첫번째 자리 , 즉 9가 있는 자리를 i라고 놓고 j는 i 다음부터 배열의 가장 작은 index를 뽑아 옵니다. 그것을 minIndex라고 하지요.

j는 8부터 배열을 검색하면서 가장 작은 index를 찾아보니 1이 있는 자리가 제일 작군요. 그러니 minIndex는 2(1이 있는 배열 원소의 위치!)가 됩니다. 그래서 가장 첫번째 자리는 1이 되겠습니다.

[https://t1.daumcdn.net/cfile/tistory/994F3E385BEFBAA520](https://t1.daumcdn.net/cfile/tistory/994F3E385BEFBAA520)

그 후 두번째 자리(8이 있는 자리)가 i가 되고, j는 그다음 가장 작은 원소의 index를 구하게 되니까 minIndex는 2가 있는 자리, 즉 4가 됩니다.

minIndex와 i를 바꿉니다.

[https://t1.daumcdn.net/cfile/tistory/998BFF3D5BEFBD4810](https://t1.daumcdn.net/cfile/tistory/998BFF3D5BEFBD4810)

다음은 9가 있는 자리입니다. i는 2가 되겠네요. 가장 작은 인덱스는 3이 있는 자리이므로 i와 바꾸어 줍니다.

[https://t1.daumcdn.net/cfile/tistory/99C12F3C5BEFC08837](https://t1.daumcdn.net/cfile/tistory/99C12F3C5BEFC08837)

다음 i가 하나 증가되어 9를 가리킵니다. 8이 더 작으니까 바꾸어 주어야겠죠??

[https://t1.daumcdn.net/cfile/tistory/99E10B335BEFC17924](https://t1.daumcdn.net/cfile/tistory/99E10B335BEFC17924)

이제 모든 비교와 교환은 끝났습니다. 오름차순으로 정렬이 된것을 볼 수 있습니다.

[https://t1.daumcdn.net/cfile/tistory/9992D03C5BEFC2682F](https://t1.daumcdn.net/cfile/tistory/9992D03C5BEFC2682F)

```java
void selectionSort(int arr[], int size) {
    int minIndex;
    int i, j;
    for (i = 0; i < size - 1; i++) {
        minIndex = i;
        for (j = i + 1; j < size; j++) 
            if (arr[j] < arr[minIndex])
                minIndex = j;
         
        swap(&arr[i], &arr[minIndex]);
    }
}
```

# 버블정렬

버블 정렬은 현재 배열 요소와 그 다음 배열 요소를 비교한다음 조건에 걸리면 교환하는 식의 정렬입니다. 그러니까 배열의 0번 인덱스의 요소와 1번 인덱스의 요소를 비교하고, 그 다음 1번 인덱스의 요소와 2번 인덱스의 요소를 비교합니다. 이 짓을 계속하면 정렬이 됩니다. 아래의 배열을 가지고 버블 정렬로 정렬해보도록 하지요.

[https://t1.daumcdn.net/cfile/tistory/996DC23A5BEFC68E31](https://t1.daumcdn.net/cfile/tistory/996DC23A5BEFC68E31)

인덱스를 j라고 표시하겠습니다. 우선 가장 앞 자리부터 그 다음 원소를 비교합니다. 9와 8을 우선 비교하는 것이죠. 9가 더 크니 8과 9를 바꿉시다.

[https://t1.daumcdn.net/cfile/tistory/993F3F3A5BEFCAA934](https://t1.daumcdn.net/cfile/tistory/993F3F3A5BEFCAA934)

그 다음 j가 하나 증가하여 다음 자리를 가리키고 9와 1을 비교합니다. 9가 더 크니 1과 9를 바꿉시다.

[https://t1.daumcdn.net/cfile/tistory/9950DE335BEFCB351F](https://t1.daumcdn.net/cfile/tistory/9950DE335BEFCB351F)

느낌 오시나요? 가장 큰 요소를 끝으로 보내려고 하는 겁니다. 다음 j를 하나 증가시키고 9와 3을 비교합니다. 9가 더크네요. 3과 9를 바꾸어줍니다.

[https://t1.daumcdn.net/cfile/tistory/99DE76345BEFCB760B](https://t1.daumcdn.net/cfile/tistory/99DE76345BEFCB760B)

다시 j가 하나 증가하게 되고 9과 2를 비교해보니 9가 더 크니까 자리를 바꾸어줍니다.

[https://t1.daumcdn.net/cfile/tistory/99F42D345BEFCBBA34](https://t1.daumcdn.net/cfile/tistory/99F42D345BEFCBBA34)

이렇게 보니까 9(제일 큰 수)가 제일 뒤로 갔군요.

[https://t1.daumcdn.net/cfile/tistory/99412B355BEFCC241A](https://t1.daumcdn.net/cfile/tistory/99412B355BEFCC241A)

그 다음은 4번째(인덱스 3)까지 이런 방식을 반복합니다. 하나씩 줄여가면서 이런 방식을 반복하여 가장 큰수를 오른쪽으로 보내면 정렬이 되는 것이죠. 버블 정렬을 코드로 구현한 것이 아래에 있습니다.

```java
void bubbleSort(int arr[], int size) {
    int i, j;
    for (i = size - 1; i>0; i--) 
        for (j = 0; j<i; j++) 
            if (arr[j]<arr[j + 1]) 
                swap(&arr[j], &arr[j + 1]);
}
```

# 삽입정렬

삽입 정렬을 우선 배열의 한 원소인 key라는 값을 우선 가지고 있고, 이 key를 알맞은 자리에 삽입하면 됩니다. key보다 큰 값은 하나하니씩 밀어버리고 key보다 작은 값을 만났으때 그 뒷자리에 삽입하는 것입니다.

그림을 통해봅시다.

우선 배열이 이렇게 있구요. 사실 계속 이 배열을 썼었죠.

[https://t1.daumcdn.net/cfile/tistory/993A294B5BEFD30715](https://t1.daumcdn.net/cfile/tistory/993A294B5BEFD30715)

우선 key값은 배열 인덱스 1번부터 시작입니다. i 이전의 원소를 비교해야하는데, 인덱스가 0이면 비교할게 없으니까요. key는 8로 8보다 큰 값은 오른쪽으로 밀어버립니다. 8보다 작은 원소가 발견되면 그 원소 뒤에 8을 삽입해야하는 데 없으므로 제일 앞에 삽입합니다.

[https://t1.daumcdn.net/cfile/tistory/9972D5355BEFDA961B](https://t1.daumcdn.net/cfile/tistory/9972D5355BEFDA961B)

8이 맨앞에 삽입 되고 난 후 i가 하나 증가하여 계속 비교합니다. key는 1이 됩니다. 1보다 작은 원소가 없으므로 제일 앞에 위치하게 됩니다.

[https://t1.daumcdn.net/cfile/tistory/9910D83C5BEFDADD1C](https://t1.daumcdn.net/cfile/tistory/9910D83C5BEFDADD1C)

[https://t1.daumcdn.net/cfile/tistory/991C85485BEFDC311B](https://t1.daumcdn.net/cfile/tistory/991C85485BEFDC311B)

이후 i가 하나 증가하고 키는 3입니다. 3보다 작은 원소를 만날때 그 뒤에 삽입하는 과정을 아래 그림이 보여줍니다.

[https://t1.daumcdn.net/cfile/tistory/998BBB485BEFDC3111](https://t1.daumcdn.net/cfile/tistory/998BBB485BEFDC3111)

[https://t1.daumcdn.net/cfile/tistory/9928DA485BEFDC3228](https://t1.daumcdn.net/cfile/tistory/9928DA485BEFDC3228)

[https://t1.daumcdn.net/cfile/tistory/9924B6485BEFDC3228](https://t1.daumcdn.net/cfile/tistory/9924B6485BEFDC3228)

이제 i가 하나 증가하게 되고 마지막 원소인 2가 키가 됩니다. 2보다 작은 원소는 1이므로 1뒤에 2를 삽입하는 것이 되지요. 아래 그림이 그 과정을 보여줍니다.

[https://t1.daumcdn.net/cfile/tistory/99361B485BEFDC321A](https://t1.daumcdn.net/cfile/tistory/99361B485BEFDC321A)

[https://t1.daumcdn.net/cfile/tistory/99F057485BEFDC330E](https://t1.daumcdn.net/cfile/tistory/99F057485BEFDC330E)

[https://t1.daumcdn.net/cfile/tistory/997799485BEFDC331F](https://t1.daumcdn.net/cfile/tistory/997799485BEFDC331F)

[https://t1.daumcdn.net/cfile/tistory/99779B485BEFDC331F](https://t1.daumcdn.net/cfile/tistory/99779B485BEFDC331F)

최종적으로 정렬된 상태는 바로 이와 같습니다.

[https://t1.daumcdn.net/cfile/tistory/997A82495BEFDD1C25](https://t1.daumcdn.net/cfile/tistory/997A82495BEFDD1C25)

```java
void insertionSort(int arr[], int size) {
    int i, j,key;
 
    for (i = 1; i < size; i++) {
        key = arr[i];
        j = i - 1;
        while (j >= 0&&arr[j]>key) {
            arr[j + 1] = arr[j];
            j--;
        }
        arr[j + 1] = key;
    }
}
```

# 병합정렬

**기본 개념**

병합 정렬을 알기 전에 우선 Devide and Conquer에 관한 개념을 알고 있어야 합니다. 아니, 몰라도 됩니다. 이제부터 배울꺼거든요. 간단히 말해 **어떤 문제를 우선 작은 문제로 쪼개고 난 후 다시 조합하여 원래의 문제를 푼다**는 것인데요.

병합정렬을 통해서 어떤 개념인지 알아보도록 하겠습니다.

우선 배열이 있습니다. 정렬이 되지 않은 정수형 배열이지요.

일단 묻지도 따지지도 않고 쪼갭니다. 아주 산산조각을 냅니다.

[https://t1.daumcdn.net/cfile/tistory/9915E3445BEFF11326](https://t1.daumcdn.net/cfile/tistory/9915E3445BEFF11326)

이 후에 쪼갠 역순으로 정렬을 하는 것입니다. 아래의 그림처럼요. 쪼갠것을 다시 차근차근 조립하면서 정렬하는 것을 볼 수 있지요.

[https://t1.daumcdn.net/cfile/tistory/99F3C9485BEFF20703](https://t1.daumcdn.net/cfile/tistory/99F3C9485BEFF20703)

그래서 우리는 이 그림을 이해하는 것이 목적입니다.

**구현**

구현은 2가지의 큰 틀로 구성이 됩니다.

**1. 분할**

가장 먼저 해야될 작업입니다. 이 작업은 쉽습니다. 배열을 그냥 2로 계속 나누다보면 언젠가는 하나의 원소를 갖게되니까 그때 멈추면 됩니다.

mergeSort라는 함수를  보세요. 정렬할 배열과 왼쪽끝을 나타내는 left, 오른쪽 끝을 나타내는 right를 인자로 받고 있습니다.

```java
void mergeSort(int arr[], int left, int right) {
 
    if(left==right) return;  
    int mid;
     
    mid = (left + right) / 2;
    mergeSort(arr, left, mid); 
    mergeSort(arr, mid + 1, right); 
     
}
```

아래의 그림처럼 left와 right를 이용해서 mid를 기준으로 쪼개는 겁니다. mid는 left와 right의 중간 부분을 가리키고 있죠.

[https://t1.daumcdn.net/cfile/tistory/99894D4F5BEFFB7817](https://t1.daumcdn.net/cfile/tistory/99894D4F5BEFFB7817)

그러다가 하나의 원소만 남게되면 바로 return이 됩니다. 어떻게 알 수 있을까요? 하나의 원소만 남았다는 것은 left와 right가 서로 같은 값을 가졌다는 것을 의미하니까 left==right라면 바로 return 하면 됩니다.

[https://t1.daumcdn.net/cfile/tistory/99BB004F5BEFFB780E](https://t1.daumcdn.net/cfile/tistory/99BB004F5BEFFB780E)

**2. 병합**

병합은 조금 어려울 수도 있지만 이해하면 별거 없습니다.

우선 코드부터 보면서 이해하자구요.

```java

void merge(int arr[], int left, int right) {
     
    int L, R, k, a;
    int mid = ( left + right ) / 2;
    L = left;
    R = mid + 1;
    k = left;
 
    while (L <= mid && R <= right)
        tmp[k++] = arr[L] <= arr[R] ? arr[L++] : arr[R++];
 
    if (L>mid) 
        for (a = R; a <= right; a++)
            tmp[k++] = arr[a];
    else
        for (a = L; a <= mid; a++)
            tmp[k++] = arr[a];
     
    for (a = left; a <= right; a++) 
        arr[a] = tmp[a];
     
}

```

뭐지 이 변태같은 코드는? 이러지 마시구요. 하나하나 보도록 합시다. 차근차근히

인자로 배열 arr과 left, right를 받고 있습니다. 나누어진 배열의 한쪽은 L, 그리고 다른 한쪽은 R을 인덱스로 하기로 합시다. 쪼개진 배열 하나를 왼쪽에 있다 생각하고 L, 다른 하나는 오른쪽에 있다고 생각하고 R로 한거에요. R은 mid+1부터 시작해야겠죠?

tmp라는 임시배열은 k를 인덱스로 합니다.

그리고 나누어 쪼개져서 정렬된 일부분의 배열을 부분 배열이라고 하겠습니다.

자, 됐으면 이제 while문을 돕니다. while루프는 왼쪽 부분 배열을 전부 다 돌았거나 오른쪽 부분 배열을 전부다 돌때까지 반복합니다. 그러니 L은 mid 이하까지 R은 right 이하까지 반복하는데 왼쪽 배열, 오른쪽 배열 하나라도 전부 반복이 되었다면 탈출합니다.

여기서부터는 그림이 좀 필요하겠네요.

[https://t1.daumcdn.net/cfile/tistory/99C369365BF0008716](https://t1.daumcdn.net/cfile/tistory/99C369365BF0008716)

왼쪽 부분 배열과 오른쪽 부분 배열의 원소를 비교해서 더 작은 값이 tmp로 값이 복사됩니다. 같을 때는 아무거나 넣어도 상관없겠죠. 그러니 현재 1과 2 중 1이 더 작으므로 tmp에 1이 저장됩니다. 그리고 L과 k를 하나씩 증가시키죠. 사실 k는 계속 증가하는 상태입니다. 항상 값이 들어가니까요.

[https://t1.daumcdn.net/cfile/tistory/99E04E365BF000881C](https://t1.daumcdn.net/cfile/tistory/99E04E365BF000881C)

그 후 arr[L]과 arr[R] 중 값이 작은 것을 또 선택합니다. 3과 2 중 2가 더 작으니 2를 tmp에 넣습니다. 이후 R과 k는 증가합니다.

[https://t1.daumcdn.net/cfile/tistory/99552B365BF0008835](https://t1.daumcdn.net/cfile/tistory/99552B365BF0008835)

마찬가지입니다. arr[L]과 arr[R] 중 가장 작은 값은 3이므로 3을 넣습니다. 그 후 k와 L의 값이 하나 증가합니다.

[https://t1.daumcdn.net/cfile/tistory/99D387365BF000880F](https://t1.daumcdn.net/cfile/tistory/99D387365BF000880F)

4까지 넣고 나면 한쪽 부분 배열(왼쪽)이 전부 tmp에 저장됐으므로 이제 while루프는 종료됩니다.

이제 남은 것을 옮겨야하는데요. 5가 남았죠?

만약 L이 mid보다 크다면 왼쪽 부분 배열이 tmp에 전부 복사된 것이므로 오른쪽에 있는 부분 배열의 값을 모조리 tmp에 집어넣습니다.

반대도 역시 똑같습니다. 오른쪽 부분 배열이 전부 tmp에 복사되었다면 R은 right보다 크게 될테니까 왼쪽 부분 배열의 남은 값을 전부 tmp에 집어넣으면 되는 것이죠.

이제 원본 배열에 값을 다시 돌려주어야합니다. tmp는 잠시 저장하는 용도로 쓰기 때문이죠.

[https://t1.daumcdn.net/cfile/tistory/99BC0E395BF003BF1C](https://t1.daumcdn.net/cfile/tistory/99BC0E395BF003BF1C)

어때요. 아름답게 정렬이 된것을 확인할 수 있죠??

merge라는 함수를 구현했으니, 이제 mergeSort에서도 이 함수를 이용해서 병합! 하면 됩니다. 아래처럼 merge 함수를 추가하세요.

```java

void mergeSort(int arr[], int left, int right) {
     
    if (left == right) return;
    int mid;
    mid = (left + right) / 2;
    mergeSort(arr, left, mid); 
    mergeSort(arr, mid + 1, right); 
    merge(arr, left, right); 
     
}

```

보다 이해가 잘 되기 위해 전체코드를 보세요.

```java
#include <stdio.h>
#define SIZE 5
int tmp[SIZE];
                     
void merge(int arr[], int left, int right) {
     
    int L, R, k, a;
    int mid = (left + right) / 2;
    L = left;
    R = mid + 1;
    k = left;
 
    while (L <= mid && R <= right)
        tmp[k++] = arr[L] <= arr[R] ? arr[L++] : arr[R++];
 
    if (L>mid) 
        for (a = R; a <= right; a++)
            tmp[k++] = arr[a];
    else
        for (a = L; a <= mid; a++)
            tmp[k++] = arr[a];
     
    for (a = left; a <= right; a++) 
        arr[a] = tmp[a];
     
}
 
 
void mergeSort(int arr[], int left, int right) {
     
    if (left == right) return;
    int mid;
    mid = (left + right) / 2;
    mergeSort(arr, left, mid); 
    mergeSort(arr, mid + 1, right); 
    merge(arr, left, right); 
     
}
void printArr(int arr[], int size) {
    int i;
    for (i = 0; i<size; i++) 
        printf("%d ", arr[i]);
     
    printf("\n");
}
void main() {
    int i;
    int arr[SIZE] = { 3,4,1,5,2 };
 
    mergeSort(arr, 0, SIZE - 1);
    printArr(arr, SIZE);
}

```

# 힙정렬 (Heap sort)

**힙 정렬(Heap Sort)**

힙에 대해서 모르는 분들은 아래 url를 참고하시기 바랄게요.

[https://reakwon.tistory.com/42](https://reakwon.tistory.com/42)

힙에 대해서 아셨다면 이제 어떻게 정렬을 하는지 알아보도록 하지요.

**정렬**

위의 url의 코드를 통해서 힙정렬을 한다고 하면 의외로 쉽습니다. 메인 함수를 이렇게 바꾸어서 실행해보세요. 정렬이 아주아주 잘됩니다.

```java
int main() {
    heap hp;
    initHeap(&hp);
    int i;
    int arr[] = { 5,3,4,1,6,10 };
    int size = sizeof(arr) / sizeof(int);
    for (i = 0; i < size; i++)
        insert(&hp, arr[i]);
 
    for (i = 0; i < size; i++)
        arr[i] = deleteData(&hp);
 
    for (i = 0; i < size; i++)
        printf("%d ", arr[i]);
    printf("\n");
}
```

근데 문제점이 있죠. arr이라는 배열 공간과 heap이라는 배열 공간 두개를 쓰니까 메모리의 낭비가 있습니다.

그리고 insert함수를 부르는 시간 nlog(n), deleteData함수를 부르는 시간 nlog(n)입니다.

**우리는 더 잘할 수 있다**

이것도 훌륭하지만 우리는 더 나아갈 수 있습니다. 더 잘할 수 있습니다.

아래의 그림은 방금 위의 배열을 단지 트리 형태로 표현한 것입니다.

[https://t1.daumcdn.net/cfile/tistory/995C8A495C0294E417](https://t1.daumcdn.net/cfile/tistory/995C8A495C0294E417)

최대힙을 구현할 것인데, 힙의 조건을 만족하지 않지요. 왜냐면 5가 가장 큰 원소가 아니거든요.

아차, heap을 구현할때는 1부터 인덱스가 시작되는데 힙정렬할땐 0부터 시작한답니다. 왜냐면 공간을 아끼기 위해 그 배열 자체를 정렬할 것이기 때문이에요. 배열의 인덱스는 0부터 시작하는 것이니까요.

**heapify**

우리는 이것을 힙의 모양으로 고치는 것, 그 함수를 heapify라고 정의해보겠습니다.

**heapify(int arr[], int here, int size)** = 크기가 size인 배열 arr을 here부터 힙의 모양대로 만드는 함수

코드와 함께 heapify가 어떻게 동작하는 지 보도록 합시다.

```java
void heapify(int arr[], int here, int size) {
    int left = here * 2 + 1;
    int right = here * 2 + 2;
    int max=here;
    if (left<size&&arr[left]>arr[max])
        max = left;
    if (right < size&&arr[right]>arr[max])
        max = right;
 
    if (max != here) {
        swap(&arr[here], &arr[max]);
        heapify(arr, max, size);
    }
}
```

이 함수 하나로 힙의 모양을 만들수는 없습니다.

아래 왼쪽의 트리에서 우리가 heapify(arr, 0, size)를 호출한다고 치면 오른쪽의 트리로 만들어지게 됩니다.

[https://t1.daumcdn.net/cfile/tistory/993B48505C029A4D1F](https://t1.daumcdn.net/cfile/tistory/993B48505C029A4D1F)

가장 작은 1이 맨 끝에 이동함을 알 수 있죠. 하지만 최대힙은 아닙니다. 4가 가장 큰 값이 아니잖아요.

우리는 이렇게 생각해볼 수 있습니다. 만약 자식을 갖고 있는 노드가 있다면 그 위치에서부터 heapify를  역순으로 호출하는 방식이죠. 그러니까 자식노드를 갖고 있는 노드는 0, 1, 2의 인덱스인데, heapify(arr, 2, size), heapify(arr, 1, size), heapify(arr, 0, size) 이렇게 호출하면 되지 않을까요?

그런 함수가 buildHeap이라는 함수입니다.

**buildHeap**

우선 우리는 자식을 갖고 있는 노드가 어떤 인덱스를 갖고 있어야하는지 알아야합니다. 어떻게 알 수 있을까요??

가장 마지막 노드는 size-1의 노드인것을 알 수 있습니다. 하지만 우리는 그 부모님 성함을 알 수 있죠. 바로 size/2 -1이 그 부모노드의 인덱스라는 것을 알 수 있습니다.

그러니까 맨 마지막의 인덱스는 5, 그 부모노드는 5/2 -1로 2가 됩니다.

이제부터 우리는

{ 5,3,4,1,6,10 }

이 배열을 heap으로 만드는 과정을 살펴봅니다.

초기는 아래와 같죠.

[https://t1.daumcdn.net/cfile/tistory/9997AE395C029DC226](https://t1.daumcdn.net/cfile/tistory/9997AE395C029DC226)

자식을 갖고 있는 노드를 알았으니 heapify(arr, 2, size)를 호출해봅시다. 그러면 위의 트리는 이렇게 바뀝니다.

[https://t1.daumcdn.net/cfile/tistory/995E9E3E5C029DFA3C](https://t1.daumcdn.net/cfile/tistory/995E9E3E5C029DFA3C)

10이 더 크니까 4와 자리를 바꾸죠.

이제 heapify(arr, 1, size)를 호출하면 다음과 같이 바뀝니다.

[https://t1.daumcdn.net/cfile/tistory/99D6FD3F5C029E3222](https://t1.daumcdn.net/cfile/tistory/99D6FD3F5C029E3222)

6이 더 크니까 3과 자리를 바꿉니다.

이제 heapify(arr,  0, size)를 호출합시다.

[https://t1.daumcdn.net/cfile/tistory/9997C43B5C029E5835](https://t1.daumcdn.net/cfile/tistory/9997C43B5C029E5835)

5의 자식 중 10이 5보다 크네요. 자리 바꿔줍니다.

루트까지 호출이 되었으니까 heapify는 종료됩니다.

어때요? 최대힙 모양이 완성되었죠?

이것을 for루프로 돌리면 아래와 같은 코드가 됩니다.

```java
void buildHeap(int arr[], int size) {
    int i,j;
    for (i = size / 2 - 1; i >= 0; i--) {
        heapify(arr, i, size);
        for (j = 0; j < size; j++)
            printf("%d ", arr[j]);
        printf("\n\n");
    }
}
```

**이제 정렬 좀 하자..**

여기까지 됐으면 거의 끝났습니다. 루트원소를 맨끝에 옮기고 다시 heapify를 호출하면 됩니다. 단, 트리의 사이즈는 하나씩 줄어듭니다.

이제 정렬과정만 보이면 되겠군요.

```java
void heapSort(int arr[],int size) {
    int treeSize;
    buildHeap(arr, size);
    for (treeSize = size - 1; treeSize >= 0; treeSize--) {
        swap(&arr[0], &arr[treeSize]);
        heapify(arr, 0,treeSize);
    }
}
```

트리의 크기가 처음에는 6입니다. 크기를 점점 줄여나가는 것을 보세요.

아래의 그림들이 위의 코드가 어떻게 동작하는지 보여줍니다.

[https://t1.daumcdn.net/cfile/tistory/99BF8E4B5C02A25F2E](https://t1.daumcdn.net/cfile/tistory/99BF8E4B5C02A25F2E)

우선 0번 노드와 5번 노드의 값을 바꾸어줍니다. 똥색 표시는 이미 정렬된 부분을 의

미합니다. 그 후 heapify를 호출하면 다시 힙의 모양을 유지하게 됩니다.

[https://t1.daumcdn.net/cfile/tistory/9935D94B5C02A26008](https://t1.daumcdn.net/cfile/tistory/9935D94B5C02A26008)

이제는 0번 노드와 4번 노드를 교환합니다. 그리고 똥색으로 표시해주고, 이제는 트리 사이즈가 4가 됩니다. 그 후 heapify를 호출해서 사이즈 4까지 힙의 모양으로 만들어 줍니다. 5가 제일 큰 노드가 되겠네요.

[https://t1.daumcdn.net/cfile/tistory/9933404B5C02A26001](https://t1.daumcdn.net/cfile/tistory/9933404B5C02A26001)

이제 0번 노드와 3번 노드를 바꿉니다. 5, 6, 10까지 정렬된 것이 보이죠?? 그 후 heapify를 호출해서 최대힙의 모양으로 유지합니다.

[https://t1.daumcdn.net/cfile/tistory/99E0E74B5C02A2601B](https://t1.daumcdn.net/cfile/tistory/99E0E74B5C02A2601B)

이제 거의 다 왔습니다. 0번 노드가 가장 크므로 마지막 노드와 교체합니다. 4까지 정렬된 것을 확인할 수 있습니다. 그 후 heapify 호출해서 heap으로 유지합니다.

[https://t1.daumcdn.net/cfile/tistory/9944C74B5C02A26132](https://t1.daumcdn.net/cfile/tistory/9944C74B5C02A26132)

이제 가장 큰 노드 0번과 1번을 바꿉니다. 3까지 정렬됐습니다. 그 후 heapify호출하여 heap의 모양으로 만들어 줍니다.

[https://t1.daumcdn.net/cfile/tistory/9933DD4B5C02A26133](https://t1.daumcdn.net/cfile/tistory/9933DD4B5C02A26133)

이제 하나남았네요. 가장 큰 노드가 자기 자신이니까 바꾸나 마나고 heapify를 호출해도 그 모양 그대로 유지합니다.

트리를 보세요! 정렬이 된것을 확인할 수 있지요??

```java
#include <stdio.h>
 
void swap(int *a, int *b) {
    int temp = *a;
    *a = *b;
    *b = temp;
}
void heapify(int arr[], int here, int size) {
    int left = here * 2 + 1;
    int right = here * 2 + 2;
    int max=here;
    if (left < size&&arr[left]>arr[max])
        max = left;
    if (right < size&&arr[right]>arr[max])
        max = right;
 
    if (max != here) {
        swap(&arr[here], &arr[max]);
        heapify(arr, max, size);
    }
}
 
void buildHeap(int arr[], int size) {
    int i,j;
    for (i = size / 2 - 1; i >= 0; i--) {
        heapify(arr, i, size);
        for (j = 0; j < size; j++)
            printf("%d ", arr[j]);
        printf("\n\n");
    }
}
 
void heapSort(int arr[],int size) {
    int treeSize;
    buildHeap(arr, size);
    for (treeSize = size - 1; treeSize >= 0; treeSize--) {
        swap(&arr[0], &arr[treeSize]);
        heapify(arr, 0,treeSize);
    }
}
void printArray(int arr[], int size) {
    int i;
    for (i = 0; i < size; i++)
        printf("%d ", arr[i]);
    printf("\n");
}
int main() {
    int arr[] = { 5,3,4,1,6,10 };
    int size = sizeof(arr) / sizeof(int);
     
    heapSort(arr, size);
    printArray(arr, size);
}
```

**시간복잡도**

힙 정렬에서 시간 복잡도는 O(nlogn)입니다. 완전 이진 트리이기때문에 높이가 균등합니다. 그래서 heapify는 logn으로 보장할 수 있습니다. 그리고 heapify를 n번 호출하기 때문에 nlogn이라는 것을 알 수 있지요.

# 퀵정렬 (Quick sort)

**퀵정렬(Quick Sort)**

오늘 다루어볼 정렬 주제는 바로 퀵정렬입니다. 이름만에서도 알 수 있듯이 빠른 속도를 자랑합니다.

하지만 다른 정렬 알고리즘에 비해서 병합정렬과 더불어 까다로운 정렬 알고리즘인데요. 사실 이해만 정확히 한다면 그리 어려운 알고리즘은 아니지요.

**개념**

퀵 정렬에서 우선 pivot이라는 개념부터 알아야합니다. 뭐 어렵지 않습니다. 그냥 비교할 기준이라고 생각하면 되겠네요.

배열의 원소들은 피봇보다 작으면 왼쪽, 피봇보다 크면 오른쪽에 놓이는데요.

바로 아래 그림을 보면서 이해하도록 합시다.

정렬되지 않은 배열 arr= **{5,6,7,3,4,2,1,9}**가 있다고 하겠습니다. 이 배열에서 피봇은 1번째 원소인 5라고 가장하겠습니다.

퀵 소트를 한번 돌게 된다면 5를 기준으로 작은 원소들은 모두 왼쪽에, 큰 원소들은 모두 오른쪽에 놓이게 됩니다.

[https://t1.daumcdn.net/cfile/tistory/993D14365C462CFF10](https://t1.daumcdn.net/cfile/tistory/993D14365C462CFF10)

이제 이런 짓을 계속하다가 보면 어느 순간 정렬된 형태가 나오는 것이죠. 병합정렬을 배운 분이라면 뭔가 보이지 않나요?

**퀵정렬의 분할정복**

퀵 정렬은 병합정렬과 마찬가지로 분할 정복의 아주 대표적인 예입니다. 하지만 정직하게 2로 나누는 병합정렬과는 다르게 퀵정렬은 비대칭으로 두동강을 내버립니다. ~~내 얼굴~~

아래 그림에서 일부를 쪼개고 다시 합치는 과정이 보이세요? 이것이 **분할-정복**의 개념입니다.

[https://t1.daumcdn.net/cfile/tistory/993F65365C46317411](https://t1.daumcdn.net/cfile/tistory/993F65365C46317411)

**분할** 퀵정렬은 우선 피봇을 기준으로 2개로 나누지요. 나누고 쪼개는 것이 바로 **분할**입니다**.** 분할을 통해서 큰 문제를 여러개의 문제로 조각을 내서 더 쉽게 문제를 푼다는 개념입니다.

**정복** 분할 이후에 다시 정렬의 과정을 거치게 됩니다.

**병합** 정복 이후 다시 합치는 과정을 **병합**이라고 합니다. 원래의 커다란 문제를 풀기 위해서는 해결했던 조각난 문제들을 다시 합쳐야하기 때문에 병합이라는 과정이 필요하죠.

**구현**

다음의 코드가 바로 퀵소트를 구현한 것입니다.

```java
void swap(int *a, int *b) {
    int t = *a;
    *a = *b;
    *b = t;
}
 
void quickSort(int left, int right, int *arr) {
    int pivot = arr[left];
    int less = left;
    int more = right+1;
     
    if (left < right) {
        do {
            do
                less++;
            while (less <= right && arr[less] < pivot);
 
            do
                more--;
            while (more >= left && arr[more] > pivot);
 
            if (less < more)
                swap(&arr[less], &arr[more]);
 
        } while (less < more);
        swap(&arr[left], &arr[more]);
         
        quickSort(left, more - 1,arr);
        quickSort(more + 1, right, arr);
    }
 
}
```

소스코드를 보면 가장 왼쪽의 원소가 피봇이라는 것을 알 수 있네요. 이 피봇값을 기준으로 작다면 배열에 왼쪽으로 놓고 크다면 오른쪽으로 놓는 것이죠. 그 후에 피봇의 위치를 찾고 다시 피봇의 위치 기준으로 배열을 쪼개서 재귀호출을 하게 됩니다.

우리는 do ~ while 문으로 위 코드를 쓰기 때문에 more은 right의 한칸 더 뒤에 있어야합니다. do ~ while문의 특징은 우선 한번은 실행시키기 때문입니다.

역시 less 그렇습니다. 가장 첫번째 left의 위치부터 시작해야 피봇 다음 원소부터 비교할 수 있는 것입니다.

어려울 수 있으니 다시 그림과 함께 이 코드를 봅시다.

[https://t1.daumcdn.net/cfile/tistory/999A864A5C4636AC16](https://t1.daumcdn.net/cfile/tistory/999A864A5C4636AC16)

우선 초기 상태는 이렇습니다. 그림에서도 볼 수 있듯이 less는 left의 위치에 있고, more은 right의 다음번째에 있습니다. 이제 do ~ while문을 실행하는 거죠.

less는 5보다 큰 원소가 있으면 멈추고 more은 5보다 작은 원소가 있으면 멈춥니다.

[https://t1.daumcdn.net/cfile/tistory/990EDF4E5C46376D14](https://t1.daumcdn.net/cfile/tistory/990EDF4E5C46376D14)

자, 6과 1이 걸리게 되겠죠? 6은 5보다 크니까 오른쪽에 있어야하고 1은 5보다 작으니 왼쪽에 있어야합니다. 그러니까 less와 more의 원소를 교환합시다. 그 후 계속 이 과정을 반복할 겁니다.

[https://t1.daumcdn.net/cfile/tistory/994F8F425C4637C215](https://t1.daumcdn.net/cfile/tistory/994F8F425C4637C215)

이제는 7과 2가 걸리게 되겠네요. 역시 교환합시다.

[https://t1.daumcdn.net/cfile/tistory/99B1704D5C4637EF14](https://t1.daumcdn.net/cfile/tistory/99B1704D5C4637EF14)

3과 4는 5보다 작으니까 지나가고 less는 7을 만나게 되면 멈춥니다. 그리고 more은 4를 만날때까지 왼쪽으로 가게 되죠. 하지만 이때 more과 less가 교차하게 됩니다. 이때 우리는 more과 less 사이의 지점, 그 지점이 바로 피봇이 위치하게 되는 지점이 되는 겁니다. 그러니 피봇이 있는 위치 left와 more과 swap하게 되면 5를 기준으로 작은 원소는 왼쪽에, 큰 원소들은 오른쪽에 위치하게 되는 것이죠.

[https://t1.daumcdn.net/cfile/tistory/9944FD505C4638A615](https://t1.daumcdn.net/cfile/tistory/9944FD505C4638A615)

최종상태는 위와 같습니다. 이제 5(pivot)을 기준으로 다시 이러한 과정을 반복하게 됩니다.

이제 이해가 되셨나요?

**시간복잡도**

위의 분할 정복의 그림에서 봤듯이 계속 두개로 쪼개 n번 비교하게 되므로 시간 복잡도는 평균적으로 **O(nlogn)**이 됩니다.

하지만 이미 정렬된 배열에서도 O(nlogn)이 나오게 될까요? 이 경우에는 **O(n^2)**이 됩니다. 피봇의 위치가 항상 왼쪽이라면 항상 2개로 쪼개지는 것이 아니라 pivot을 제외한 배열을 정렬하게 되는 샘이지요.

[https://t1.daumcdn.net/cfile/tistory/99A7B54D5C463B4017](https://t1.daumcdn.net/cfile/tistory/99A7B54D5C463B4017)

하지만 퀵소트가 빠른 점은 바로 pivot은 정렬에 포함시키지 않기 때문이죠. 그러므로 병합정렬보다 빠릅니다. 

그러니까 이름이 Quick Sort이지요.

그리고 퀵 정렬은 배열의 공간외에는 다른 공간을 쓰지 않기 때문에 공간복잡도는 O(n)입니다.

# 재귀함수 **Recursion Function**

### **재귀 (Recursion)**

프로그래밍에서 재귀(Recursion)란 자신을 정의할 때 자기 자신을 재참조하는 것을 말한다. 따라서 재귀 함수란 함수가 호출되어 실행할 때, 함수 내부에서 자기 자신을 다시 호출하는 **재귀 호출(Recursive call)**의 형태를 말한다.

### **Recursive vs Iterative**

보통 Recursive와 Iterative가 많이 비교되곤 한다. Iterative는 '반복적인'이란 뜻을 가지고 있다. 즉, 우리가 흔히 사용하는 for문이나 forEach문과 같은 반복 연산을 가리킨다. 항상 그런 것은 아니지만 많은 경우에 Recursion으로 처리할 수 있는 문제는 Iterator로도 처리할 수 있고, 반대로 Iterator로 처리할 수 있는 것은 Recursion으로 처리할 수 있다. 어떤 방법으로 문제를 해결하느냐는 프로그래머의 마음이지만 때로는 Iterative 코드보다 Recursive 코드를 사용했을 때 더 이해하기 쉬운 코드가 될 때가 있다. 그러므로 우리는 두 가지 방법을 모두 명확하게 알고 있어야 한다.

재귀 호출을 이해하기 위해서는 **스택(Stack)**이라는 자료 구조를 먼저 살펴보는 것이 좋다. 왜냐면 우리의 컴퓨터는 호출 스택이라고 불리는 스택을 사용하여 함수를 실행하기 때문이다. 호출 스택은 일반적인 프로그래밍에서도 중요하지만 재귀를 사용할 때 더욱 중요하다.

### 재귀의 3가지 중요한 특성

모든 재귀 함수는 3가지의 중요한 특성을 갖습니다.

### 종료 조건

간단하게, `if(나쁜 값이 들어왔다면) { 정지! };`과 같이 이해하시면 됩니다. 종료 조건은 재귀의 안전장치입니다. 종료 조건을 여러분들의 긴급 브레이크처럼 생각하세요. 좋지 않은 입력 값이 들어왔을 때, 재귀가 계속하여 동작하는 것을 방지해줍니다. 위의 팩토리얼 예제에서, `if (x < 0) return;`은 우리가 설정한 종료 조건입니다. 음수의 팩토리얼을 구하는 것은 불가능합니다. 그래서 우리는 음수 입력 값이 들어왔을 때, 팩토리얼 함수가 작동하지 않길 원합니다.

### 기반 조건(Base case, 기저 상태)

간단하게, `if(이런 일이 일어난다면) { 성공! }`과 같이 이해하시면 됩니다. 이 조건 역시 재귀 함수를 멈춘다는 점을 감안하면, 기반 조건은 어쩌면 재귀의 종료조건과 비슷합니다. 하지만 종료 조건은 모든 나쁜 데이터들을 잡아낸 다는 것을 기억하세요. 반면에 기반 조건은 재귀 함수의 *목적* 입니다. 기반 조건은 주로 `if` 문 내부에 있습니다. 팩토리얼 예제에서는, `if (x === 0) return 1;`이 기반 조건이었습니다. x가 0까지 내려갔을 때, 우리는 팩토리얼을 구하는데 성공한 것입니다!

### 재귀

간단하게, 함수가 자기 자신을 호출하는 것입니다. 팩토리얼 예제에서, `return x * factorial(x -1);`부분이 실제로 재귀가 일어나는 곳입니다. 우리는 숫자 `x`가 `factorial(x-1)`함수의 결과 값으로 곱해진 어떤 값을 반환합니다.

### **팩토리얼 (Factorial) 구하기**

재귀 함수를 설명할 때 가장 많이 등장하는 예제 코드가 바로 팩토리얼 구하기이다. 팩토리얼이란 자기 자신부터 시작해서 1 감소한 숫자들을 곱한 값이다. 예를 들어서 **5!**은 **5 * 4 * 3 * 2 * 1** = 120이다.

팩토리얼을 먼저 Iterative 코드로 작성해보면 다음과 같다.

```jsx
function factorial (n) {
	var result = 1;
	for (var i = n; i >= 1; i--) {
		result *= i;
	}
	return result;
}

```

n부터 1까지의 수를 반복하여 result 변수에 곱한다. 곱셈을 해야 하므로 result 변수의 초기값은 당연히 1이어야 한다.

재귀 함수로 만들어보자. 만약에 factorial(5)부터 factorial(1)을 쭉 써보면 다음과 같을 것이다.

**factorial(5) = 5 * 4 * 3 * 2 * 1 = 5 * factorial(4);**

**factorial(4) = 4 * 3 * 2 * 1 = 4 * factorial(3);**

**factorial(3) = 3 * 2 * 1 = 3 * factorial(2);**

**factorial(2) = 2 * 1 = 2 * factorial(1);**

**factorial(1) = 1;**

재귀 함수를 작성하여 호출하면 함수는 자기 자신을 계속해서 호출하여 실행한다. 이 때 특정 조건이 되었을 때, 재귀 호출을 종료하는 문장이 반드시 하나 이상 존재해야 하는데, 이렇게 재귀 호출을 중단시키는 조건 문장을 **Base case** 또는 **Termination case** 라고 한다.

```jsx
function factorial (n) {
	if (n === 1) { // Base case, Termination case
		return 1;
	}
	return n * factorial(n - 1);
}
factorial(3); // 6

```

1. 먼저 파라미터 n의 값으로 **3**이 전달된다.
2. stack에 3을 저장하고 **factorial(3 - 1) = factorial(2)**을 실행한다.
3. n의 값으로 **2**가 전달된다. stack에 2를 저장하고 **factorial(2 - 1) = factorial(1)**을 실행한다.
4. n의 값으로 **1**이 전달된다. n이 1이면 1을 리턴하고 함수를 종료한다.
5. factorial(1)이 1을 return하고 종료하였으므로 2 * 1을 연산하고 그 값인 **2**를 return한다.
6. 리턴된 2와 3을 곱한 후 그 값인 **6**을 리턴하고 모든 함수가 종료된다.

![https://blog.kakaocdn.net/dn/dgAk2U/btqvUQ7tEFp/cc57tKac2iSZKaScLeRTck/img.png](https://blog.kakaocdn.net/dn/dgAk2U/btqvUQ7tEFp/cc57tKac2iSZKaScLeRTck/img.png)

factorial 함수에 대한 각각의 호출이 자신만의 n값의 사본을 가지고 있다는 사실을 꼭 기억해야 한다. 서로 다른 함수 호출에 대한 n값에는 접근할 수 없다.

### **재귀 함수를 사용했을 때의 단점**

위에서 살펴봤듯이 재귀 함수를 사용하면 함수의 호출이 스택에 차곡 차곡 쌓이게 되고, 위에서부터 차례대로 값을 반환하기 전에는 계속 메모리 공간을 차지하고 있다. 그렇기 때문에 호출 스택이 너무 커져서 메모리를 엄청나게 소비할 수도 있다. 이러한 이유 때문에 재귀를 사용하는 것보다 반복문을 사용했을 때 더 성능이 좋은 경우가 많다. 그러므로 상황에 따라 적절한 방법을 골라서 사용할 수 있어야 한다.

[알고리즘 - 그래프 탐색(깊이 우선 탐색 - DFS)](https://hongjw1938.tistory.com/42)

# 빈도수 체크

```jsx
/**
* Time Complexity - O(n)
* 두개의 개별 반복문이 두개의 중첩 반복문 보다 효율이 훨씬 좋다
* 개별 반복문을 통해서 분리한 두개의 객체에 정보를 담아서 비교를 하는 방식으로 사용하면
* 기존의 중첩 반복문을 사용하지 않고 비교하는데 더 용이하다
*/

function same(arr1, arr2){
	if(arr1.length !== arr2.length){
		return false;
  }

	let frequencyCounter1 = {};
	let frequencyCounter2 = {};

	for(let val of arr1){
		frequencyCounter1[val] = (frequencyCounter1[val] || 0 ) +1;
	}

	for(let val of arr2){
		frequencyCounter2[val] = (frequencyCounter2[val] || 0 ) +1;
	}

	for(let key in frequencyCounter1){
		if(!(key ** 2 in frequencyCounter2){
			return false;
		}
		if(frequencyCounter2[key **2] !== frequencyCounter1[key]){
			return false;
		}

	}

	return true;

}

const result = same([1,2,3],[9,1,4]);

console.log(result);
```

객체에서 key값을 가지고 in으로 탐색하는게 빠른가 아니면 배열에서 indexOf로 순번을 찾는게 빠를까?

⇒ 테스트 후 결과를 기입해 놓자!!!!!

Anagrams 예제 

<aside>
💡 두개의 문자열이 일치하는지 비교하는 문제
validAnagram(’abc’,’ccc’); // false
validAnagram(’abc’,’cba’); // true

소문자로만 생각하면됨. 
문제에 대한 의문이 생기면 출제자에게 좀 더 구체적인 제한 사항을 물어봐야한다.

</aside>

- My solution
    
    ```jsx
    const validAnagram = function(w1,w2){
    	w1 = w1.split('').sort();
    	w2 = w2.split('').sort();
    
    	if(w1 === w2) return true;
    
    	const wordObj1 = {};
    	const wordObj2 = {};
    
    	for(word of w1){
    		wordObj1[word] = (wordObj1[word] || 0) + 1;
    	}
    	
    	for(word of w2){
    		wordObj2[word] = (wordObj2[word] || 0) + 1;
    	}
    
    	for(key in wordObj1){
    		if(wordObj1[key] !== wordObj2[key]{
    			return false;
    		}
    	}
    
    	return true;
    }
    ```
    
    단어이면서 소문자 등의 제약사항 때문에 문자들을 정렬한 다음 비교해서 반환해도 결과는 같을것 같다.
    
    빈도수 체크에 대한 선행 학습한 내용을 너무 그대로 사용해서 해결하려 했다. 필요없는 로직이나 다른 문법등을 응용해서 적용해봤어도 될 것 같은데 아직은 사고력이 좀 부족한 것 같은 느낌이다. 
    
- lecture solution
    
    ```jsx
    const validAnagram = function(w1,w2){
    	if(w1.length !== w2.length){
    		return false;
    	}
    	
    	const lookup = {};
    
    	for(let i = 0; i<w1.length; i++){
    		let letter = w1[i];
    		lookup[letter] ? lookup[letter] += 1 : lookup[letter] = 1;
    	}
    
    	for(let i = 0; i<w2.length; i++){
    		let letter = w2[i];
    		
    		// 0이 false값을 반환한다는 개념을 알았지만 실제 사용은 안해봤는데 
    		// 이런식으로도 검증 로직에서 사용하면 더 간단하게 표현도 가능하다는것을 다시 생각해보게 되었다.
        // 하지만 다른 언어 기준에서 볼 때도 이 문장이 이해가 되는 부분이 있을까??
    		if(!lookup[letter]){
    			return false;
    		}else{
    			lookup[letter] -= 1;
    		}
    	}
    
    	return true;
    }
    ```
    

# 다중포인터 ( 탐색, 변경 )

인덱스나 위치에 해당하는 포인터나 값을 만든 다음 특정 조건에 따라 중간 지점에서부터

시작 지점이나 끝 지점이나 양쪽 지점을 향해 이동시키는 것

다중 포인터 패턴은 리팩토링의 이점을 가지게 된다. 

- 포인터를 사용하지 않은 반복문

```jsx
function sumZero(arr){
	for(let i = 0; i<arr.length; i++){
		for(let j = 0; j<arr.length; j++){
			if(arr[i] + arr[j] === 0){
				return [arr[i] , arr[j]];
			}
		}
	}
}
```

Time Complexity : O (N^2)

Space Complexity : O(1)

- 포인터를 사용한 리팩토링 코드

```jsx
function sumZero(arr){
	let left = 0;
	let right = arr.length - 1;

	while(left < right){
		let sum = arr[left] + arr[right];
		if(sum === 0){
			return [[arr[left] , arr[right]];
		}else if(){
			right--;
		}else{
			left++;
		}
	}
}

// test Arr
[-3,-2,-1,0,1,2,3] // true
[-2,0,1,3] // false
[1,2,3] // false
```

Time complexity : O(n)

Space Complexity : O(1)

- 두 개의 포인터를 사용한 비교
    
      i
    
    [1,1,1,1,1,2,3,4,5,6]
    
         j
    
      i
    
    [1,1,1,1,1,2,3,4,5,6]
    
           j
    
    이런 형태로 j 포인터를 한칸씩 이동 시키면서 i와 비교 후 다르면 i를 다음 칸으로 이동 시키면서 
    
    i값을 j값으로 변경
    

```jsx
function counterUniqueValues(arr){
	if(arr.length === 0) return 0;

	let p1 = 0;
	let p2 = 1;

	for(let i = 1; i<arr.length; i++){
		if(arr[p1] !== arr[p2]){
			p1++;
			arr[p1] = arr[p2];
		}
		p2++;
	}
	
	return p1+1;
}
```

Time Complexity : O(n)

Space Complexity : O(n)

Set을 사용하면 위의 포인터를 사용하지 않고 중복 제거가되어 고유 항목만 남게되기 때문에 

Time Complexity 가 O(1)을 가지게 된다. 

```jsx
const result = new Set([1,1,1,1,1,2,3,4]); // 1,2,3,4
const length = result.size;
console.log(length);
```

# 기준점간 이동 배열 패턴 ( SlidingWindow )

## 문제

- 주어진 숫자 만큼 연속된 숫자의 가장 큰 합계
- 예시)
    
    배열 : [ 1,2,5,2,8,1,5] 
    
    숫자 : 2
    
    ⇒ 연속된 2개의 가장 큰 합계 : 2,8의 합 10이 출력
    
    배열 : [1,2,5,2,8,1,5]
    
    숫자 : 4
    
    ⇒ 연속된 4개의 가장 큰 합계 : 5,2,8,1의 합 17이 출력
    
- Worst Solution
    
    많은 양의 배열이 주어지게 되면 시간이 무한정 늘어나게 된다. 
    
    ```jsx
    function(arr,num){
    	if(num > arr.length){
    		return null;
    	}
    	
    	var max = -Infinity; /*음수의 합계도 담아야 하는 경우가 생겨서 0으로 처리 안함*/
    	let temp;
    	for(let i = 0; i< arr.length - num + 1; i++) {
    		temp = 0;
    		for(let j = 0; j < num; j++){
    			temp += arr[i + j];
    		}
    		if(temp > max){
    			max = temp;
    		}
    	}
    
    	return max;
    }
    
    // Time Complexity : O(N^2)
    ```
    
- Best Solution
    
    전체 배열을 한번만 탐색해서 값을 찾기 때문에 위의 방식보다 효율적이다. 
    
    원리 : 포인터가 이동되면서 이전과 다음 값이 다르게 되는 숫자들을 더하고 빼는 과정으로 처리
    
    [ 2,6,9,2,1,8,5,6,3]
    
       -       +
    
         -        +
    
            -        +
    
    ```jsx
    function maxSubarraySum(arr , num){
      let maxSum = 0;
      let tempSum = 0;
    
    	if(arr.length < num) return null;
    
    	// 첫번째 합계를 구함
    	for(let i = 0; i< num; i++){
    		maxSum += arr[i];
    	}
    
    	// 첫번째 합계를 임시로 저장
    	tempSum = maxSum;
    
    	// 첫번째 합계를 가지고 더하고 빼면서 값을 비교
    	for(let i = num; i<arr.length; i++){
    		tempSum = tempSum - arr[i - num] + arr[i];
    
    		// 두개의 수에서 최대값 저장
    		maxSum = Math.max(maxSum,tempSum);
    	}
    
    	return maxSum;
    }
    // Time Complexity - O(N)
    ```
    
    ## 고려할 사항
    
    단순하게 생각해서 이중 반복문으로 처리하는 경우가 많은데 로직에서 규칙을 잘 찾아서 규칙에 대한 수식을 스스로 만들어 보는게 가장 중요한 것 같다. 문제에 대해서 조금만 다르게 생각하고 반복되는 규칙성이 없는지도 한번씩 살펴보자
    

# 분할 정복 패턴 ( Divide Conquer )

Divede and Conquer ( 분할 정복 패턴 )
배열이나 문자열 같은 큰 규모의 데이터셋을 처리
값을 찾기 위해 배열의 왼쪽에서 시작하여 오른쪽 끝까지 이동하는 것보다는
배열의 작은 조각으로 세분하여 각 조각들을 어디로 이동시킬지 결정하는 작업을 먼저 진행
즉 큰 데이터 덩어리를 작은 조각으로 나누는 것
탐색 알고리즘의 이진 탐색 혹은 일반 탐색이라는 알고리즘이 전형적인 예시

- A naive solution
    
    ```jsx
    
    function search(arr, value) {
      for (let i = 0; i < arr.length; i++) {
        if (arr[i] === value) {
          return i;
        }
      }
    
      return -1;
    }
    // Time Complexity : O(N)
    
    const result1 = search([1, 2, 3, 4, 5, 6, 7], 4); // 3
    const result2 = search([1, 2, 3, 4, 5, 6, 7], 6); // 5
    const result3 = search([1, 2, 3, 4, 5, 6, 7], 11); // -1
    ```
    
- Refactor
    
    > 중간 값을 추출하여 찾을 값과 비교 후 찾을 값보다 큰 그룹에서
    다시 중간 값을 찾아서 찾을 값과 비교 하고 그룹화 하는 방식으로 진행하여 찾음.
    그렇기 때문에 배열은 정렬이 되어 있어야하며 비교 가능한 식이어야 함.
    > 
    
    ```jsx
    function search(arr, value) {
      let min = 0;
      let max = arrary.length - 1;
    
      while (min <= max) {
        let middle = Math.floor((min + max) / 2);
        let currentElement = array[middle];
    
        if (currentElement < val) {
          min = middle + 1;
        } else if (currentElement > val) {
          max = middle - 1;
        } else {
          return middle;
        }
      }
    
      return -1;
    }
    // Time Complexity : Log(N) - Binary Search
    ```
    

# 재귀(Recursion)

## 재귀란?

- 자기 자신을 호출하는 절차

## 재귀 활용예시

- JSON.parse , JSON.stringify
- document.getElementById , DOM traversal apgorithms
- 복잡한 구조를 가진 데이터를 다룰 때

<aside>
💡 때로는 재귀함수를 사용않는게 가독성이나 효율성이 더 좋다.

</aside>

## Javascript Call Stack

```jsx
function takeShower(){
	return "showering";
}

function eatBreakfast(){
	let meal = cookFood();
	return `Eating ${meal}`;
}

function cookFood(){
	let items = ['Oatmeal','Eggs','Protein'];
	return items[Math.floor(Math.random()*items.length)];
}

function wakeUp(){
	takeShower();
	eatBreakfast();
	console.log("go to work")
}

wakeUp();
```

## 재귀 수행 원리

### 2가지 기본 원칙

- 종료 지점이 존재해야함.
- 다른 입력값을 전달해야함.
- 예시1)
    
    ```jsx
    function countDown(num){
    	if(num < 0){
    		console.log("all done!!");
    		return;
    	}
    
    	console.log(num);
    	num--;
    	countDodwn(num);
    }
    
    countDown(5);`
    ```
    
- 예시2)
    
    ```jsx
    function sumRange(num){
    	if(num === 1) return 1; //종료지점
    	return num + sumRange( num - 1 );// 다른 입력값과 다른 반환값
    }
    
    sumRange(5);
    ```
    
- 예시3)
    
    ```jsx
    function factorial(num){
    	if(num === 1) return 1;
    	return num * factorial( num - 1 );
    }
    
    factorial(5);
    ```
    

## 재귀의 잠재적 위험

- 종료조건을 잘못 설정
- 종료 조건으로 향하는 다른 값을 입력하지 않았을때
- 잘못된 값을 반환할 때

⇒ stack overflow 발생

## Helper method Recursion

- outer function
    
    외부 함수를 개발자 또는 사용자가 호출
    
- inside function
    
    내부에서 재귀 함수 선언 및 호출
    
- 함수를 호출한 다음에도 변수를 저장해서 전역변수 형태로 계속 사용하기 위해서 사용
    - 예시)
    
    ```jsx
    function collectOddValues(arr){
    	let result = [];
    	
    	function helper(helperInput){
    		if(helperInput.length === 0){
    			return;
    		}
    		
    		if(helperInput[0] % 2 !== 0){
    			result.push(helperInput[0]);
    		}
    
    		helper(helperInput.slice(1));
    
    	}
    
    	helper(arr)
    
    	return result;
    }
    
    collectOddValues([1,2,3,4,5,6,7,8]);
    ```
    

## 순수 재귀 Pure Recursion

- 가독성은 helper recursion이 더 좋다

```jsx
function collectOddValues(arr){
	let newArr = [];

	if(arr.length === 0){
		return newArr;
	}

	if(arr[0] % 2 !== 0){
		newArr.push(arr[0]);
	}

	// concat function or spread 연산자 사용
	newArr = newArr.concat(collectOddValues(arr.slice(1)));

	return newArr;

}

let result = collectOddValues([1,2,3,4,5,6]);
```

## 재귀함수 연습문제

- 연습1)
    
    ```jsx
    // Math.pow() function 같은 기능을 재귀로 구현
    
    function power(baseNum , expandNum){
    	if(expandNUm === 0) return 1;
    	return num * power(baseNUm,expandNum -1);
    }
    ```
    

- 연습2)
    
    ```jsx
    // 모든 배열의 값을 곱한 값 구하기
    
    function productOfArray(arr){
    	if(arr.length <= 1){
    		return arr [0];
    	}
    
    	return arr[0] * productOfArray(arr.slice(1));
    }
    ```
    

- 연습3)
    
    My Solution
    
    ```jsx
    // 피보나치 수열의 n번째 수 구하기
    
    function fib(num){
    	let prevNum = 0;
    	let curNum = 1;
    
    	function helper(count = num){
    		if(num <= 2){
    			return prevNum + curNum;
    		}
    
    		const nextNum = prevNum + curNum;
    		prevNum = curNum;
    		curNum = nextNum;
    
    		return helper();
    	}
    }
    ```
    
    Lecture  Solution
    
    ```jsx
    function fib(n){
    	if(n <=2 ) return 1;
    	return fib(n-1) + fib(n-2);
    }
    ```
    
    해설
    
    ```jsx
    			      								fib(5)
          	 fib(4)                +              fib(3)
        fib(3) + fib(2)                      fib(2) + fib(1)
    fib(2) + fib(1)
    
    fib(2) + fib(1) = 2
    fib(3) + fib(2) = 3
    fib(4) + fib(3) = 5
    ```
    
- 연습4)
    
    앞 뒤 문자열이 동일한 지 비교
    
    예시)
    
    ‘amanaplanacanalpanama’ // true
    
    ‘tacocat’ // true
    
    ‘awesome’ // false
    
    ```jsx
    function isPalindrome(text){
    	if(text.length < 2) return true;
    	if(text.slice(0,1) !== text.slice(-1)) return false;
    
    	return isPalindrome(text.slice(1,-1));
    }
    ```
    

 

- 연습5)
    
    주어진함수를 통해서 전달된 배열이 참인지 확인
    
    [1,2,3,4,5] , val ⇒ val % 2 !== 0 // true
    
    [4,6,8] , val % 2 !== 0 // false
    
    [4,6,8], val > 10 // false
    
    ```jsx
    function someRecursive(arr, callback){
    	if(arr.length === 0) return false;
      return callback(arr[0]) || someRecursive(arr.slice(1),callback);
    }
    ```
    

- 연습6)
    
    다중 배열 1차원 배열로 변환
    
    [1,2,3,[4,5]] ⇒ [1,2,3,4,5]
    
    [1,2,3,[ [ [],[4,5] ] ] ] ⇒ [1,2,3,4,5]
    
    ```jsx
    const resultArr = [];
    
    function flatten(arr){
    	if(arr.length === 0) return;
    	
    	const item = arr.shift();
    	if(Array.isArray(item)){
    		flatten(item);
    	}else{
    		resultArr.push(item);
    	}
    
    	flatten(arr);
    }
    
    const result = flatten([1,2,3,4,[5,6]]);
    ```
    

- 연습6)
    
    다차원배열을 1차원 배열로 변환
    
    ```jsx
    const result = [];
    
    function flatten(arr){
    	if(arr.length === 0) return;
    
    	const item = arr.shift();
    
    	if(Array.isArray(item)){
    		flatten(item);
    	}else{
    		resultArr.push(item);
    	}
    
    	flatten(arr);
    }
    
    flatten([1,2,3,[4,5,[6,7,8]]]);
    ```
    

- 연습7)
    
    object 의 value 중 number 만 문자열로 변경
    
    ```jsx
    function stringifyNumbers(obj){
    	for(key in obj){
    		if(typeof obj[key] === 'number'){
    			obj[key] = obj[key].toString();
    		}
    		if(typeof obj[key] === 'object' && !Array.isArray(obj[key)){
    			stringifyNumbers(obj[key]);
    		}
    
    	}
    	
    	return obj;
    }
    
    const obj = {
    	num : 1,
    	test :  [],
    	data : {
    		val : 4,
    		info : {
    			isRight : true,
    			random : 66
    		}
    	}
    }
    
    const result = stringifyNumbers(obj);
    ```
    

<aside>
💡 재귀에 대한 원리를 단순히 재호출의 개념으로만 파악하다보니 응용되는 문제들이 다른길로 돌아가는것 같다.  스택이라는 구조와 같이 파악해서 다시 호출 됨과 동시에 이전의 값을 스택으로 저장하고 있다는 것을 잊지 말자. 재귀 문제는 규칙성과 이전값을 얼마나 잘 다루느냐에 따라 다르게 풀리는 것 같다.
재귀를 사용할 때 주의 할 것은 아무리 좋은 재귀함수라도 대량의 데이터는 stack이 과도하게 쌓여 overflow가 발생 할 수 있다.
종료조건!!! , 다른 값의 전달!!!! 두가지만 기억해도 stackoverflow는 나지 않는다.

</aside>

# 선형검색(linearSearch)

## 개념

- 세트 간격으로 이동하면서 한번에 하나의 항목을 확인하는 식으로 모든 항목을 확인하는 방식

## javascript에서 선형 검색 함수

- indexOf
- includes
- find
- findIndex

## 연습문제

- 배열에서 제시한 값의 index를찾는 함수
    
    ```jsx
    function linearSearch(arr,findVal){
    	for(let i = 0; i<arr.length; i++){
    		if(arr[0] === findVal) return 1;
    	}
    	return -1;
    }
    ```
    

## Big O

- Best Case : O(1)
- Worst Case : O(n)
- Average Case : O(n)

# 이진검색(binarySearch)

- 검색 할 때 마다 반 만큼의 자료를 없앨 수 있다.
- 주의할 점은 분류된 배열을 대상으로만 작동한다.
- 배열의 중간 지점 값을 주어진 값과 비교 후 2개로 나눠진 배열에서 다시 주어진 값에 해당하는 배열에서 중간 지점 값과 비교

## 연습문제

my solution

```jsx
function binarySearch(arr,findVal){
	let idx = Math.ceil(arr.length/2)
	for(let i = 0; i<arr.length; i++){
		if(arr[idx] === findVal){
			return idx;
		}
		if(arr[idx] > findVal){
			idx = idx/2;
		}
		if(arr[idx] < findVal){
			idx = Math.ceil((idx + arr.length) / 2;)
		}
	}
}
```

lecture

```jsx
function binarySearch(arr,findVal){
	let start = 0;
	let end  = arr.length - 1;
	let middle  = Math.ceil((start + end) / 2);
	
	while(arr[middle] !== findVal && start <= end){
		if(findVal < arr[middle]){
			end = middle - 1;
		}else{
			start = middle + 1;
		}
		middle = Math.ceil((start + end) / 2);
	}

	return arr[middle] === findVal ? middle : -1;
}
```

## Big O

- Best Case : O(1)
    - 중간지점의 값을 한번에 찾은 경우
- Worst Case : O(log n)
    - 모든 지점을 체크하는 경우
    - 찾는 값이 없을때 모든 지점을 체크하게됨
    - 하지만 다른 검색과 비교했을때 매우 빠른속도를 가지고 있음

# 비교 알고리즘 (Comparison Sort)

> 비교 알고리즘(Comparison Sorts)에 속하는 항목들이다. 두개의 항목을 비교하여 더 작은것 더 큰것을 비교하여 나열
> 

# Basic 정렬

- 컬렉션(collection)의 항목을 재배열하는 과정
- 프로그래밍에서 흔하게 사용되는 알고리즘이다
- 데이터를 정렬할 수 있는 방법이 많고 각각의 장단점이 있다
- 여러가지의 정렬방법을 알면 상황에 맞게 최적화된 정렬을 할 수 있다.
- 정렬알고리즘을 애니메이션으로 볼수 있는 사이트 :  sorting algorithms animations
- 정렬 알고리즘을 시각적으로 실행 단계를 볼 수 있는 곳 :  visualgo

## Javascript has method

- sort()
- 선택적 비교함수를 인자로 전달 받는다
    - sort((a,b) ⇒ a-b) :  ASC
    - sort((a,b) ⇒ b-a) : DESC
- swap function
    
    ```jsx
    // ES5
    function swap(arr, idx1, idx2){
    	var temp = arr[idx1];
    	arr[idx1] = arr[idx2]
    	arr[idx2[ = temp;
    }
    
    // ES2015
    const swap = function (arr,idx1,idx2) => {
    	[arr[idx1] , arr[idx2]] = [arr[idx2] , arr[idx1]]
    }
    ```
    

## 버블정렬(bubbleSort)

- 효율적인 정렬은 아니다.
- 다른 정렬 알고리즘과 비교 및 분석하는데 도움이 된다.

no optimize 

```jsx
function bubbleSort(arr){
	for(let i = arr.length; i > 0; i--){
		for(let j = 0; j < i - 1; j++){
			if(arr[j] > arr[j+1]){
				let temp = arr[j];
				arr[j] = arr[j+1];
				arr[j+1] = temp;
			}
		}
	}

	return arr;
}
```

optimize

- 이미정렬이 다 됬음에도 계속해서 남은 항목을 정렬하기 위해 진행됨
- 정렬이 다 되었다고 판단되는 경우 loop를 멈출 수 있도록 로직 추가

```jsx
function bubbleSort(arr){
	var noSwaps;
	for(let i = arr.length; i > 0; i--){
		noSwaps = true;
		for(let j = 0; j< i - 1; j++){
			if(arr[j] > arr[j+1]){
				let temp = arr[j];
				arr[j] = arr[j+1];
				arr[j+1] = temp;
				noSwaps = false;
			}
		}
		if(noSwaps) break;
	}
	return arr;
}
```

## Big O

- Time Complex : O(n^2)
- optimze time Complex : O(n)

## 선택정렬(selectionSort)

- 버블 정렬과 다르게 추출한 값을 끝에 위치시키는것이 아니라 한번에 하나씩 위치에 배열
- 정렬데이터는 처음부터 누적이 됨
- 최소값을 찾아 맨 앞에 위치 시킴

### 구현

```jsx
function selectionSort(arr){
	for(var i = 0; i<arr.length; i++){
		var lowest = i;
		for(var j = i +1; j<arr.length; j++){
			if(arr[j] < arr[lowest]){
				lowest = j;
			}
		}
				
		if( i !== lowest){ //optimize
			var temp = arr[i]
			arr[i] = arr[lowest];
			arr[lowest] = temp;
		}
	}
	return arr;
}
```

### Big O

- Time Complex : O(n^2)
- 선택정렬이 버블보다 나은 경우는 스왑수를 최소화 했을 때 뿐이다. (흔한 경우는 아님)

# Hard 정렬

## 삽입정렬 ( Insertion Sort )

- 한번에하나의 항목을 올바른 위치에 삽입해서 배열의 정렬된 부분을 점진적으로 구축
- 배열의 두번째 요소부터 시작
- 첫번째 요소를 정렬된 부분으로 간주
- 두번째 값을 앞의 값과 비교 후 자리 이동 결정
- 세번째 값을 첫번째 값, 두번째 값을 비교하여 위치 결정

구현

```jsx
function insertionSort(arr){
	for(var i = 1; i < arr.length; i++){
		var currentVal = arr[i];
		for(var j = i-1; j>=0 && arr[j] > currentVal; j--){
			arr[j+1] = arr[j]
		}
		arr[j+1] = currentVal;
	}

	return arr;
}
```

BigO

- Time Complex : O(n^2)
- 데이터가 거의 정렬된 경우 : O(n)
- best : O(1)

삽입정렬을 사용하는 유용한 경우

- 온라인 알고리즘이라는 데이터가 있는 경우
- 기존에 정렬된 데이터가 있고 신규 데이터가 들어와서 재 정렬되야 할 때 유용
- 전체배열을 다시 정렬할 이유가 없고 매번 새로운 데이터를 수신하는 경우

## 합병정렬 ( Merge Sort)

- 정렬된 두 배열 합병을 담당할 함수를 먼저 구현
- 정렬된 두 배열이 주어지면 정렬된 새 배열을 만들어야함
- 두 배열은 같은 방식의 정렬이 되어 있어야함. ( 오름차순, 내림차순등..)
- O(n+m) 의 복잡도를 가진다

원리

N배열 

[1,10,50]

M배열

[2,14,99,100]

1. 1과 2를 비교
2. 빈 배열에 더 작은 수 할당 [1]
3. N배열 위치를 shift하여 10으로 이동 
4. 10과 2를 비교 더 작은수 할당 [1,2]
5. M배열 위치를 shift하여 14로 이동
6. 10과 14를 비교 더 작은수 할당 [1,2,10]
7. N배열 위치를 shift하여 50로 이동
8. 50과 14를 비교 더 작은수 할당 [1,2,10,14]
9. M배열 위치를 shift하여99로 이동
10. 50과 99를 비교 더 작은수 할당 [1,2,10,14,50)
11. N배열의 위치가 더이상 shift 할 곳이 없음
12. M배열의 남은 항목 그대로 할당 [1,2,10,14,50,99,100] ( 이런 부분 때문에 비교되는 두배열이 같은 방식의 정렬을 필요로함)

구현

```jsx
function merge(arr1, arr2){
	let results = [];
	let i = 0;
	let j = 0;

	while(i < arr.length && j < arr2.length){
		if(arr2[j] > arr1[i]){
			results.push(arr1[i]);
			i++;
		}else{
			results.push(arr2[j]);
			j++;
		}
	}

	while(i < arr1.length){
		results.push(arr1[i]);
		i++;
	}

	while(j < arr2.length){
		results.push(arr2[j])
		j++;
	}

	return resuls;

}
```

Big O

- Time Complex : O(n log n)
- Space Complex : O(n)

## 퀵 정렬 ( Quick Sort )

- 합병 정렬처럼 가정으로 시작
- 재귀를 통해 해결
- pivot의 위치를 선정할 때 될 수 있으면 중간 값을 선택하는게 최선이다. 하지만 데이터가 무었인지 알수 없는 상황이 많기 때문에 어렵다.
- 편의상 첫번째 요소를 pivot 위치로 잡고 실행

```jsx
function pivot(arr, start=0){
	function swap(array, i, j){
		var temp = array[i];
		array[i] = array[j];
		array[j] = temp;
	}

	// ES2015+
	// const swap = (arr,idx1,idx2) => {
	//    [arr[idx1] , arr[idx2]] = [arr[idx2] , arr[idx1]]
	// }

	var pivot = arr[start];
	var swapIdx = start;

	for(var i = start + 1; i<arr.length; i++){
		if(pivot > arr[i]){
			swapIdx++;
			swap(arr, swapIdx, i);
		}
	}
	swap(arr,start,swapIdx);
	return swapIdx;
}

function quickSort(arr, start=0, end=arr.length){
	if( start < end ){
		let pivotIndex = pivot(arr, start);

		// pivotIndex를기준으로 left 영역
		quickSort(arr,start,pivotIndex-1);
		// pivotIndex를기준으로 right 영역
		quickSort(arr, pivotIndex+1, end);
	}
	return arr;
}

const result = quickSort([4,6,9,1,2,5,3])
```

Big O

- Time Complex (Best) : O(n log n)
- Time Complex (worst) : O(n ) → 데이터가 이미 정렬된 경우에도 피벗을 사용하여 분할하는 행위를 그대로 반복하게된다. 적어도 정렬된 경우에서는 무작위로 피벗요소를 고르거나 중간에 있는 요소를 피벗 시작지점으로 선정하는게 낫다. 매번 첫번째나 마지막을 피벗으로 선정하면 최악의 시나리오가 발생할 수 있다.
- Time Complex (average) : O( )

# 정렬 알고리즘

> 데이터의 특별한 속성을 이용한 정렬
예를 들면 정수 정렬 알고리즘 이라는 그룹은 정수로만 수행
> 

## 기수 정렬 (Radix Sort)

- 직접 비교하지 않는다.
- 숫자로 작동
- 실제로 사용할 때는 이진수를 사용
- 문자열이나 이미지등도 이진형식으로 바꾸어서 사용
- 정렬시 실제 데이터는 십진법 숫자 이어야 한다.
- 숫자 크기에 대한 정보를 자릿수로 인코딩 한다.
- 자리수가 더 큰수 가 있다면 더 큰수가 된다. ( 4자리수 > 2자리수 )

작동원리

[ 1566, 4, 3556, 593, 408, 4386, 902, 7, 8157, 86, 9637, 29 ]

첫번째 그룹핑

10개의 버킷을 구성하여 마지막 자리수를 기준으로 나눠 담는다.

0 : 

1 :

2 : 902

3 : 593

4 : 4

5 : 

6 : 86, 4386, 3556, 1556

7 : 9637, 8157, 7

8 : 408

9 : 29

두번째 그룹핑

10개의 버킷을 구성하여 끝에서 두번째 자리수를 기준으로 나눠 담는다.

한자리 숫자는 2번째 수가 없기 때문에 0번쨰에 위치

0 : 408, 7 ,4, 902

1 :

2 : 29

3 : 9637

4 : 

5 : 8157 , 3556, 1556

6 : 

7 : 

8 : 86, 4386

9 : 593

이런방식으로 가장 긴 자리수의 숫자만큼 진행 

10진수 일떄라서 10개의 버킷

7진수는 7개의 버킷

2진수는 2개의 버킷  이런 방식으로 버킷을 구성

해당 번째 자리에서 숫자를 알 수 있어야 정렬이 가능하다. → 특정 조건에서만 정렬 가능

해당 번째의 수를 알기 위한 helper 함수가 필요

```jsx
function getDigit(num , i){
	return Math.floor(Math.abs(num) / Math.pow(10,i)) % 10;
}

getDigit([1,2,3,4,5] , 0); => 5
getDigit([1,2,3,4,5] , 1); => 4
```

버킷 정렬을 몇번이나 진행할 지 최대 길이의 수를 얻는 함수

```jsx
function digitCount(num){
	if(num === 0) return 1;
	return Math.floor(Math.log10(Math.abs(num))) + 1;

}

function mostDigits(){
	let maxDigits = 0;
	for(let i = 0; i<nums.length; i++){
		maxDigits = Math.max(maxDigits, digitCount(nums[i]));
	}
	return maxDigits;
}

mostDigits([1,2,3,4,123]);
```

두개의 helper함수를 활용한 기수 정렬 

- 의사코드
    - 숫자목록을 받는 함수 정의
    - 가장 큰수가 몇자리 인지 확인
    - 각 자리수 버킷을 만든다 ( 10진수는 10개의 버킷 )
    - 끝 자리수에 해당하는 숫자를 버킷에 해당하는곳에 할당
    - 기존 배열을 버킷의 값으로 변경 ( loop필요 없이 concat or spread 를 사용)
    - 그다음 끝에서 2번째 자리 숫자를 버킷에 해당하는곳에 할당
    - 기존 배열을 버킷의 값으로 변경
    - 가장 큰 수의 자리수 까지 반복

```jsx
function radixSort(nums){
	let maxDigitCount = mostDigits(nums);
	
	for(let k = 0; k < maxDigitCount; k++){
		let digitBuckets = Array.from({length:10},() => []);
		for(let i = 0; i < nums.length; i++){
			let digit = getDigit(nums[i],k);
			digitBuckets[digit].push(nums[i);
		}
		nums = [].concat(...digitBuckets);
	}

	return nums;
}
```

### Big O

- Time Complex
    
    
    | Complex | BIg O |
    | --- | --- |
    | Best | O(nk) |
    | Average | O(nk) |
    | Worst | O(nk) |
- Space Complex
    
    
    | Average | O(n + k) |
    | --- | --- |
- 일반적으로 인정되는 표기이다.
- 일반적으로 기수정렬이 비교정렬보다 빠르지만 메모리수에 저장하는 방법의 차이로 실제로는 다를 수 있다.

# ES2015 Class Syntax

```jsx
class Student {
	constructor(firstName , lastName , year){
		this.firstName = firstName;
		this.lastName = lastName;
		this.grade = year;
		this.tardies = 0;
		this.scores = [];
	}

	fullName(){
		return `Your full name is ${this.firstName} ${this.lastName}`;
	}

	markLate(){
		this.tardis += 1;
		if(this.tardies >= 3){
			return "YOU ARE EXPERLLED!!!!";
		}
		return `Your full name is ${this.firstName} ${this.lastName} has neen late${this.tardies} times`;
	}

	addScore(score){
		this.scores.push(score);
		return this.scores;
	}
	
}

let fitstStudent = new Student('Colt','Steele',4)
let secondStudent = new Student('Blue','Steele',1)

firstStudent.fullName(); // Colt Steele

```

# 자료구조 (Data Structure)

- 해당 데이터에 적용되는 값들 및 기능 혹은 작업들 사이의 관계를 포함한다.
    - Array를 예로 들어보면 Array는 많은 값들을 가지고 있다 그리고 값들 사이의 관계 역시 표함 하고 있다. 포함된 값들 간의 상호작용 값들의 추가방법 이동방법 등 모든 종류의 내장 메소드를 다루고 있다.
- 데이터의 모음을 저장하게 되고 많은 메소드들을 작성하게 될것이다.
- 

## 왜 많은 자료구조들이 필요할까

- 데이터를 저장하는 기능을 동일하게 가지고 있더라도 자료간의 관계를 맺는 방법이 다르다
- 그래서 검색을 하는 최적회된 방법들이 다르다
- 각각의 관계에 맞는 효율적인 탐색을 위해서 자료구조들을 파악할 필요가 있다.
- 어떤 자료구조가 가장 좋은가에 대한 질문은 잘못되었다. 특정 상황에 따라 좋은 자료구조가 다르다.

# 단일 연결 리스트 (Singly Linked Lists)

- 단방향 연결 리스트란?
- 단일 연결 리스트 와 array list 구조 비교
- 클래스 정의 및 함수 생성

## 단방향 연결 리스트란?

- 자료구조
- 문자열, 숫자등 무었이던 원하는 데이터를 저장하는 자료구조
- 순서에 따라 다수의 데이터를 저장
- 어레이와 차이점
    - 다음 데이터 엘리먼트를 가리키는 익덱스 없이 그냥 다수의 데이터 엘리먼트들로 구성
    - 연결되어 있는 기차같은 모양
    - 첫번째부터 접근해야지만 특정 인덱스에 접근 가능
    - 엘리멘드틀을 노드라고 부른다
    - 노드들은 다음 노드를 가리키는 정보를 저장. 아무값도 없을시 null을저장
    - 헤드 : 연결리스트의 시작노드 가르킴
    - 테일 : 연결리스트의 마지막 노드를 가르킴
    - 길이 : 전체 노드의 개수
- 엘리베이터가 없는 건물로 생각. 5층을 가기 위해서는 1,2,3,4 층을 거쳐야함

```jsx
class Node{
	constructor(val){
		this.val = val;
		this.next = null;
	}

}

class SinglyLinkedList{
	constructor(){
		this.head = null;
		this.tail = null;
		this.length = 0;
	}

	push(val){
		var newNode = new Node(val);
		if(!this.head){
			this.head = newNode;
			this.tail = this.head;
		}else{
			this.tail.next = newNode;
			this.tail = newNode;
		}
		this.length++;
		return this;
	}

	pop(){
		if(!this.head) return undefined;
		var current = this.head;
		var newTail = currend;
		while(current.next){
			newTail = current;
			current = current.next;
		}
		console.log(current.val);
		console.log(newTail.val);

		this.tail = newTail;
		this.tail.next = null;
		this.length--;

		if(this.length === 0){
			this.head = null;
			this.tail = null;
		}
		return current;
	}

	shift(){
		if(!this.head) return undefined;

		var currentHead = this.head;
		this.head = currendHead.next;
		this.length--;
		
		if(this.length === 0){
			this.tail = null;
		}
		return currentHead;
	}

	unShift(val){
		var newNode = new Node(val);

		if(!this.head){
			this.head = new Node;
			this.tail = this.head;
		}else {
			newNode.next = this.head
			this.head = newNode;
		}

		this.length++;
		return this;
	}

	get(index){
		if(index < 0 || index >= this.length) return null;
		var counter = 0;
		var current = this.head;
		while(counter !== index){
			current = current.next;
			counter++;
		}
		return current;
	};

	set(index, val){
		var foundNode = this.get(index);
		if(foundNode){
			foundNode.val = val;
			return true;
		}

		return false;
	}

	insert(){
		if(index < 0 || index > this.length){
			return false;
		}

		if(index === this.length) return !!this.push(val);

		if(index === 0) !!this.unshift(val);

		var newNode = new Node(val);
		var prev = this.get(index-1);
		var temp = prev.next;
		prev.next = newNode;
		newNode.next = temp;
		this.length++;
		return true;
	}

	remove(index){
		if(index < 0 || index >= this.length) return undifined;
		if(index === 0) return this.shift();
		if(index === this.length -1) return this.pop();
		var prevNode = this.get(index -1);
		var removed = prevNode.next;
		prevNode.next = removed.next;
		this.length--;
		return removed;
	
	}

	print(){
		var arr = [];
		var current = this.head;
		while(current){
			arr.push(current.val);
			current = current.next;
		}
		console.log(arr);
	}

	reverse(){
		var node = this.head;
		this.head = this.tail;
		this.tail = node;

		var next;
		var prev = null;

		for(var i = 0; i < this.length; i++){
			next = node.next;
			node.next = prev;
			prev = node;
			node = next;
		}
	}

}
```

## Big O

- insertion : O(1)
- Removal : O(1) 가장처음값 or O(n) 가장마지막값
- Searching : O(n)
- Access : O(n)