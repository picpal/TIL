
What is Docker? And Why?

도커 : 컨테이너 기술

컨테이너를 생성하고 관리

컨테이너 : 표준화된 소프트웨어 유닛 , 코드패키지 . 
소스코드 + 런타임 + 기타도구 

동일한도구 동일한 환경으로 동일한 동작결과를 낼수 있다

피크닉 바구니 처럼 생각 . 바구니 안에 음식과 접시 돗자리등으로 어디든 바구니만 들고가면 피크닉을 할 수 있다.



왜 필요할까?
독립적은 표준화된 어플리케이션 패키지를 원할까?
개발 제품 생산 환경을 가지게 된다. 
NodeJs 14.3 에서 성공적인 코드를 작성 
but 로컬, 서버환경이 달라 지게 되면 코드 실행에서 오류가 나타날 수 있다. 
문제 파악에 상당한 시간이 필요할 수 있다.

코드가 항상 정확한 버전으로 실행되도록 함
잠재적인 문제 발생 방지

팀이나 회사내의 각각의 개발환경 통일
배포하지 않은 경우에도 배포환경과 동일한 환경에서 테스트 할 수 있음
프로젝트가 여러개인 경우 도커를 사용하면 버전 충돌을 방지 할 수 있다.




가상머신을 사용하면 되지 않는가?
설치된 운영체제 위에 가상의 운영체제를 새로 설치
즉 컴퓨터 내의 컴퓨터로 보임
여러개의 가상머신으로 여러개의 운영체제를 구동 할 수 있음.

![[Pasted image 20230802225131.png]]
하지만 몇가지 문제가 있음
가상머신에서의 오버헤드 발생. 여러대의 머신이 있는 경우 메모리 CPU 하드드라이브 사용을 많이 하게됨
가상머신이 많아질 수록 문제가됨 . 그리고 운영체제 또한 각각 다 설치되야해서 무겁다.

장점
분리된환경
환경별 구성가능
안정적 공간

단점
중복운영체제
낭비되는 성능으로 성능저하
재생산 공유가 가능하지만 모든 시스템에 다시 설정해야함. 
정확하게 같은 환경을 구축하기 까다로움




도커사용
하나의 운영체제위에 컨테이너 지원 환경 생성
그 위에 도커 엔진을 생성 
도커엔진 위에 컨테이너들을 생성
![[Pasted image 20230802225658.png]]

도커는 운영체제 . 도구 등 가벼운 버전을 가지고 있음
이미지를 통해서 동일한 컨테이너를 생성하여 구동 할 수 있다. 


가상머신과 도커컨테이너 차이점
![[Pasted image 20230802225924.png]]





# Docker 설치

## Mac
- 시스템 요구사항 충족 시
	- Docker Desktop 설치
- 시스템 요구사항 미충족 시 
	- Docker Toolbox 설치

## Window
- 시스템 요구사항 충족 시
	- Docker Desktop 설치
- 시스템 요구사항 미충족 시 
	- Docker Toolbox 설치

## Linux
- 리눅스는 기본적으로 모든 곳에서 사용가능 특정요구 사항이 없음
- 기본적으로 도커 엔진을 지원, 직접설치 가능
- Docker Desktop & Docker Toolbox 필요 없음
- 도커가 사용하는 기술과 컨테이너를 기본적으로 지원

# 실행방식
도커는 linux 에서 실행되며 다른 OS 에서 사용하기 위해서 가상머신이 필요하다
위에서 프로그램 설치시 시스템 요구사항을 충족했다면 시스템의 OS위에서 가상환경을 구축하여 도커를 실행한다


# IDE 설치 & 구성하기

Vscode 사용
Package 에 Docker 설치


# Images & Container

패드 필기 확인



# finding / creating Images
## 존재하는 이미지를 사용하는 방법
- 동료가 이미 구축
- 일반적이어서 미리구축된 공식 이미지
- 커뮤니티에서 공유한 이미지
- ex) Docker hub 

## 스스로 이미지를 만들어서 사용하는 방법
- 공식이미지를 가져온다음 그위에 코드를 추가하여 그이미지로 코드를 실행
- 컨테이너 내부에서 작업실행




# Dockerfile

```docker
# 어떤 이미지를 사용하는지 기재

# 로컬에 존재하는 이미지명 또는 Docker hub 의 이미지 이름

FROM node

  

# 명령이 실행되야하는 경로를 지정

WORKDIR /app

  

# 로컬에 있는 어떤 파일이 이미지에 들어가야 하는지

# 두개의 경로

# 첫번째 경로 (Host file system): 이미지로 복사되어야 할 파일들이 있는 곳

# . 을 넣게되면 기본적으로 Dockerfile이 포함된 동일한 폴더라고 알림

# 이프로젝트의 모든 폴더를 모두 라는 의미

# 두번째 경로 (images/container file system) : 이미지 내부의 경로

# 기본적으로 도커 default 경로로 보는것 보다 사용자가 직접 지정해주는게 좋다.

#

# . /app 과 같이 명령어를 입력하게되면 컨테이너 내부의 app 폴더에 Dockerfile 의 모든

# 파일들이 복사된다는 의미

#

# WORKDIR 을 지정하였다면 root folder는 WORKDIR 폴더 기준

# 따라서 . /app => . ./ 로 변경가능

# 하지만 가독성은 . /app 이런 형태가 더좋다.

COPY . ./

  

## 파일 복사 후 실행할 명령어

RUN npm install

  

# 도커 컨테이너는 격리되어있다.

# 지역 환경과 격리되어있다.

# 자체 내부 네트워크도 있다.

# 컨테이너 내부의 포트를 실행하려 할때 그 포트를 로컬에 노출하지 않는다

# 컨테이너 내부에서만 무언가를 수신 대기 중이다.

# 로컬에 특정 포트를 노출하고 싶다는 것을 표기

# EXPOSE는 도큐먼트 성격이라 아무것도 하지 않는다. 
# 실행을 위해서는 docker build -p [로컬포드]:[컨테이너포트] [docker ID]
# -p : publish 의미

EXPOSE 80

  

# RUN은 이미지가 생성될 때 실행,

# CMD는 이미지를 기반으로 컨테이너가 시작될 때 실행

# CMD를 특정하지 않으면 베이스 이미지가 실행되며, 그게 없는 경우 에러가 발생

CMD ["node","server.js"]
```


Dockerfile을 작성 후  명령어 실행
build 시 dockerfile의 위치를 알려주며 어디서 실행하는지 표기 
```
docker build .
```


실행을 위한 명령
```
docker run -p 3000:80 c899ab84404f
```

추가 사항
Dockerfile의 '`EXPOSE 80`'은 선택 사항이라는 점을 다시 한 번 명확히 하고 싶습니다. 그것은 컨테이너의 프로세스가 이 포트를 노출할 것임을 **문서화**하는 겁니다. 하지만 '`docker run`'을 실행할 때 '`-p`'를 사용하여 실제로 포트를 노출해야 합니다. 따라서 기술적으로 '`-p`'는 포트에서 수신 대기할 때 **유일하게 필요한 부분**입니다. 하지만 Dockerfile에 'EXPOSE'를 추가하여 이 동작을 문서화하는 것이 **모범적인 사용법**입니다.

추가 **참고 사항**: **ID**를 사용할 수 있는 모든 **docker 명령**의 경우, **항상 전체 ID를 복사**/기록할 필요는 **없습니다**.

첫 번째(몇 개) 문자를 사용할 수도 있습니다. 고유 식별자를 갖는 것만으로도 충분합니다.

그래서

1. docker run abcdefg

이 명령 대신

1. docker run abc

이 명령을 실행할 수도 있습니다.

또는 "a"로 시작하는 다른 이미지 ID가 없으면, 다음과 같은 명령을 실행할 수도 있습니다.

1. docker run a

**이는 ID를 필요로 하는 모든 Docker 명령어에 적용됩니다.**

---

# 이미지 레이어 이해하기

이미지는 레이어 기반
- 이미지를 빌드하거나 , 재빌드 시 변경된  부분의 명령과 그 이후의 모든 명령이 재평가된다.
- 도커는 기본적으로 모든 명령어에 대해 이전과 동일한 명령이라고 인식하게 되면 캐시 처리되어 더 빠르게 이미지 빌드가 진행된다. 
- 이미지를 빌드할 때 마다 모든 명령 결과를 캐시하고 이미지를 다시 빌드 할 때 캐시된 결과를 사용한다. 
- 레이어 기반 아키텍처라고 한다. 
- 이미지는 읽기 전용이다. 즉 이미지가 빌드되고 실행되면 이미지가 잠기고 다시 빌드하지 않는 한 코드를 변경 할 수 없다. 

[[Container Based On An Image]]


- Dockerfile의 명령어 한줄 한줄이 이미지의 레이어다
- 프로젝트 파일중 하나의 파일이 변경이 되는 것이 감지 되면 캐싱된것을 사용하는게 아니라 새롭게 실행한다. 
- 중간의 하나의 레이어가 변경된것이 감지되면, 후속의 모든 레이어 들도 캐싱이 아니라 다시 실행한다. 
- 이 때문에 불필요하게 실행되는 레이어(명령어) 들이 있는데 이를 최적화 하기 위해 순서를 변경하여 실행할 수 있다. ex) npm install 은 의존서부여가 되었을 때만 재실행이 필요. 하지만 COPY 명령어 뒤에 RUN : npm install 이 있게되면 프로젝트 파일이 변경될 때 마다 npm install 이 실행되게 된다. ( 중간의 하나의 레이어 변경감지로 인해 후속 레이어 모두 실행). #최적화


# 첫번째 요약

```
docker run node
```
'node' 이미지를 기반으로 컨테이너를 만들어 실행하는 명령어
이미지가 로컬에 없으면 Dockerhub에서 찾으려 시도함.


---

# 이미지 & 컨테이너 관리

docker --help 를 통해서 여러가지의 부가 기능을 확인 할 수 있다. 

## 이미지
- 태그
- 리스트 확인
- 분석 및 검사
- 제거

## 컨테이너
- 이름 설정
- 세부구성
- 세부제어 
- 리스트 확인
- 다시시작
- 제거


